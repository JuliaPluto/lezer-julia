@precedence {
  interp
  immediate
  symbol

  imports
  imports-2
  renamed-import @right

  subscript
  
  dot @left
  single-is-special
  unary
  postfix
  transpose
  typeonlyascription @left
  
  type-parameters
  typeascription @left
  where @left

  prefix
  call

  // https://docs.julialang.org/en/v1/manual/mathematical-operations/#Operator-Precedence-and-Associativity
  power @left
  coefficient
  bitshift @left
  times @left
  plus @left
  colon @left
  pipe @left
  pipeback @right
  contains @left
  band @right
  bor @right

  suffix
  
  ternary @right
  pair @right
  forbinding

  something-statement
  return

  baretuple
  assign @right
  arrow @right

  macro-argument
  macro

  array
  array-comprehension

  // This makes it so `[a $b]` is parsed correctly,
  // but it makes `[a $ b]` not work, sadly.
  // But I care more about the former ðŸ¤·â€â™€ï¸
  matrix
  plus_but_sometimes_interpolation @right

  for-statement
  statement @right

  right0 @right
  regular0
  regular-1
} 

@top SourceFile {
  expressionList
}

// EXPRESSIONS

expression {  
  blocky_things |
  definition |
  MacroExpression |
  FunctionExpression |
  CallExpression |

  // TODO Imports is slow!
  import_expressions |
  
  Identifier |
  boolean |
  Character |
  Number |
  String |
  Symbol |

  CoefficientExpression |
  UnaryExpression |
  BinaryExpression |
  TernaryExpression |
  
  SpreadExpression |
  Where |
  LonelyType |
  Operator ~op |
  BeginIndex |
  EndIndex |

  InterpolationExpression |
  FieldExpression |
  TransposeExpression |
  SubscriptExpression |
  QuoteExpression |
  TripleString |
  CommandString |
  PrefixedString |
  
  // NOTE TupleExpression actually makes lezer generate FASTER?
  TupleExpression |
  GeneratorExpression |
  ArrayExpression |
  ArrayComprehensionExpression |
  MatrixExpression |
  MatrixExpressionWithOnlySemicolons |
  
  // TODO Discontinued vector might/is still used by some macros
  // .... but it also adds a couple of seconds to the build...
  // .... So changed it for TypeArgumentList for now...
  // .... Not fully accurate, but acurate enough?
  TypeArgumentList |

  TypedExpression |
  ParameterizedIdentifier | 
  
  ParenthesizedExpression
}


@skip { whitespace | Comment | BlockComment }

// TOP LEVEL

expressionList {
  terminator*
  (
    statement
    (
      terminator+
      (!statement statement)
    )*
    terminator*
  )?
}

// # STATEMENTS
// AssignmentStatement and BareTuple are the only
// nodes that can only exist at the top level of blocks:
// Inside anything the BareTuple can't exist because it becomes
// a normal tuple, and assignment also can't have BareTuple inside
// so it become a AssignmentExpression instead.
statement {
  (expression | AssignmentStatement | BareTuple)
}
BareTuple {
  expression (!baretuple "," expression)+ 
}
// Wonderful how making this a whole separate thing works, but nesting it
// inside AssignmentStatement as `BareTuple ","?` does not ðŸ¤·â€â™€ï¸
BareTuple_with_comma[@name="BareTuple"] {
  expression (!baretuple "," expression)* ","
}
AssignmentStatement[@name="AssignmentExpression"] {  
  // So I finally think I understand what `!assign` here does:
  // Lezer is not sure if, before reduce-ing `Assignee`, it should parse
  // `@m x = 10` as `(@m x) = 10` or as `@m (x = 10)`.
  // By telling it just before the reduce "Hey, if you got here, take this
  // instead of something with a lower precedence" (e.g. a macro call),
  // we make sure lezer parses this correctly
  // Assignee {
    (expression | BareTuple | BareTuple_with_comma)
    !assign
  // }
  (assignOperator | "=")
  statement
}

AssignmentExpression {
  // Using `Assignee` here makes stuff like `c -> x = true` parse as
  // `(c -> x) = true` rather than `c -> (x = true)` ðŸ˜’
  expression
  !assign
  (assignOperator | "=")
  (expression | AssignmentExpression)
}

// BLOCKY THINGS

blocky_things {
  IfStatement |
  // IfStatement_Pro |
  TryCatchFinally |
  ForStatement |
  WhileStatement |
  LetStatement |
  ConstStatement |
  GlobalStatement |
  LocalStatement |
  QuoteStatement |
  BreakStatement |
  ContinueStatement |
  ReturnStatement |
  CompoundExpression
}

// IfStatement but with block matching working...
// Also creates a less readable tree, so
// TODO Look into how closedBy and openedBy is
// .... interpreted by the codemirror extension.
IfStatement_Pro {
  blockkw<"if", "else elseif end"> 
  IfClause { expression }
    expressionList
  (
    // TODO Should have openedBy="if elseif" too?
    blockkw<"elseif", "else elseif end">
    ElseIfClause { expression }
    expressionList
  )*
  (
    // TODO Should have openedBy "if elseif"?
    blockkw<"else", "end">
    ElseClause { expressionList }
  )?
  end
}

IfStatement {
  IfClause { kw<"if"> expression }
    expressionList
  ElseifClause*
  ElseClause?
  end
}
ElseifClause {
  IfClause { kw<"elseif"> expression }
  expressionList
}
ElseClause {
  kw<"else">
  expressionList
}

TryCatchFinally[@name="TryStatement"] {
  blockkw<"try", "catch finally end">
  expressionList
  Catch?
  Finally?
  end
}
Catch[@name="CatchClause"] {
  blockkw<"catch", "finally end">
  (CatchBinding { Identifier } | terminator)
  expressionList
}
Finally[@name="FinallyClause"] {
  blockkw<"finally", "end">
  expressionList
}

// TODO Should the `in`s be closedBy/openedBy too?
ForStatement {
  !for-statement
  blockkw<"for", "end">
  ForBinding
  ("," ForBinding)*
  expressionList
  end
}

WhileStatement {
  blockkw<"while", "end"> WhileBinding { expression }
    expressionList
  end
}

BreakStatement {
  kw<"break">
}

ContinueStatement {
  kw<"continue">
}

ReturnStatement {
  // kw<"return"> (!return statement)? terminator
  kw<"return"> (!return statement)?
}

LetStatement {
  blockkw<"let", "end">
  LetBinding {
    (expression | AssignmentExpression)
    ("," (expression | AssignmentExpression))*
  }?
  terminator
  expressionList
  end
}

ConstStatement {
  kw<"const"> !something-statement AssignmentStatement
}

GlobalStatement {
  kw<"global"> !something-statement statement
}

LocalStatement {
  kw<"local"> !something-statement statement
}

QuoteStatement {
  blockkw<"quote", "end">
  expressionList
  end
}

/////////////////
// IMPORT STUFF
/////////////////

import_expressions {
  ImportStatement |
  ExportStatement
}

importable {
  Identifier |
  MacroIdentifier |
  Operator
}

ImportStatement {
  (kw<"using"> | kw<"import">)
  (Imports | SelectedImport)
}
ExportStatement {
  kw<"export"> importable (!right0 "," importable)*
}

dot { "." | immediate_dot }

Import {
  RelativeDots { !imports-2 (!imports-2 dot !imports-2)+ }?
  Property { importable !imports-2 dot }*
  // importable
  Name { importable }
  Rename { kw<"as"> importable }? 
}
Imports {
  Import (!imports "," Import)*
}
SelectedImport {
  Import !renamed-import immediate_colon Imports
}

// DEFINITIONS

definition {
  PrimitiveDefinition |
  AbstractDefinition |
  StructDefinition |
  MutableStructDefinition |
  ModuleDefinition |
  BareModuleDefinition |
  MacroDefinition |
  FunctionDefinition
}
Definition { expression }
FunctionDefinition {
  !regular0 blockkw<"function", "end">
    Definition
    expressionList
  end
}
MacroDefinition {
  blockkw<"macro", "end"> Definition
    expressionList
  end
}

PrimitiveDefinition {
   "primitive type" Definition Number end
}

AbstractDefinition {
  "abstract type" Definition end
}

StructDefinition {
  blockkw<"struct", "end"> Definition
    expressionList
  end
}
MutableStructDefinition {
  "mutable struct"
  // blockkw<"mutable", "end"> blockkw<"struct", "end">
  Definition
    expressionList
  end
}


ModuleDefinition {
  blockkw<"module", "end"> Definition
    expressionList
  end
}

BareModuleDefinition {
  blockkw<"baremodule", "end"> Definition
    expressionList
  end
}

// @dynamicPrecedence to make this prefered over `Identifier TypeArgumentList`
ParameterizedIdentifier[@dynamicPrecedence=1] {
  expression
  !type-parameters
  ImmediateTypeArgumentList
}
ImmediateTypeArgumentList[@name="TypeArgumentList"] {
  immediate_brace inner_tuple "}"
}
TypeArgumentList {
  "{" inner_tuple "}"
}

FieldName { word }

FieldExpression {
  expression
  immediate_dot
  (FieldName | Symbol | QuoteExpression | InterpolationExpression)
}

begindex_start[@export="begindex_start"] { 
  immediate_bracket
}
begindex_end[@export="begindex_end"] { 
  "]"
}

SubscriptExpression {
  expression
  !subscript
  begindex_start // [
  inner_tuple
  begindex_end // ]
}

SpreadExpression {
  expression !dot "..."
}

TernaryExpression {
  expression
  !ternary ternary1 !ternary
  expression
  !ternary ternary2 !ternary
  expression
}

TypedExpression {
  // Value { expression !typeascription }
  expression
  !typeascription
  (operator<"::"> | operator<"<:">)
  Type { !typeascription expression }
}

Where {
  expression
  !where
  kw<"where">
  Type { !where expression }
}

CompoundExpression {
  begin
    expressionList
  end
}

// TODO Has more edge cases:
// .... but `a'(a)` being `(a')(a)`
// .... or `(10)x` still being `10 * x`
// .... or `(x)x` being `x * x`
// .... but `(:d)x` being a syntax error?
// .... And a lot more most likely
CoefficientExpression {
  (Number | TransposeExpression)
  !coefficient
  Coefficient {
    // Need to investigate what `!coefficient` here does
    !coefficient nowhitespace expression |
    ParenthesizedInsideCoefficient[@name="ParenthesizedExpression"] {
      immediate_paren inner_tuple ")"
    }
  }
}

// @dynamicPrecedence is necessary to nudge `x()` to `CallExpression`
// instead of `Indentifier TupleExpression`
CallExpression[@dynamicPrecedence=1] {
  expression
  !call
  Dot[@name="BroadcastDot"] { immediate_dot }?
  ArgumentList
}

DoClause {
  blockkw<"do", "end"> 
  (
    // Disabled this for now... broke a lot of odd things...
    // Like with `expression` here it parsed `asd::Vector{Bar}`
    // as `(asd::Vector){Bar}` but it should be (asd)::Vector{Bar}`
    // SO ODD!! WHAT DO DOCLAUSEARGUMENTS HAVE TO DO WITH THAT!
    //
    DoClauseArguments { expression ("," expression)* } |
    // DoClauseArguments { do_clause_argument ("," do_clause_argument)* } |
    terminator
  )
  expressionList
  end
}

ListCompherension {
  expression comprehensionClause
}


LonelyType {
  (operator<"::"> | operator<"<:">)
  Type { !typeonlyascription expression }
}

//////////
// Quoting and interpolation
//////////
InterpolationExpression[@name=Interpolation, @dynamicPrecedence=10] {
  interpolationStart expression interpolationEnd |
  // TODO Make this "$" also InterpolationStart?
  interpolation_start symbol_name
}

Symbol {
  // TODO Make this ":" also QuoteStart?
  symbol_start !symbol symbol_name
}
symbol_name {
  // The reason Symbol and QuoteExpression can co-exist is because
  // Symbol matches on `word`, which is just like identifier BUT
  // will match earlier... so Symbol will "snatch" all the
  // wordy symbols right from QuoteNode...
  // TODO Don't think this distinction is useful though
  Identifier { word } |
  Number |
  String |
  Operator |
  // So assign operators are special because you can't use them as
  // normal identifiers e.g. `+` is valid code, `+=` isn't, while `:+=` is!
  AssignOperatorAsSymbols[@name=Operator] { assignOperator }
  // TODO Allow all operators here explicitly so they get tagged as
  // .... Symbol rather than QuoteExpression (if we keep the distinction)
}

QuoteExpression[@name=Quote,@dynamicPrecedence=10] {
  quoteStart inner_paren quoteEnd |
  // Prefer the inner_paren way
  TupleExpression[@dynamicPrecedence=-1] {
    quoteStart inner_tuple quoteEnd
  } |
  quoteStart AssignOperatorInSymbols[@name=Operator] { assignOperator | "=" } quoteEnd
}


////////////
// Tuples, arguments and ParenthesizedExpression
////////////
tuple_section {
  (
    ListCompherension |
    (expression | AssignmentExpression)
    ~tuple-vs-parens
    (
      ("," (expression | AssignmentExpression))*
      ("," ListCompherension?)?
    )?
  )
}
inner_tuple {
  tuple_section?
  // Calling this `Parameters` now for backwards compatibility...
  // but I feel like all inner_tuples in a TupleExpression should
  // be equal and just "inner" or something
  ((";")+ Parameters { tuple_section })*
  (";")*
}

TupleExpression {
  "(" inner_tuple ")"
}

ArgumentList {
  immediate_paren inner_tuple ")" 
  DoClause?
}

// When a tuple has one element `(a)`
// or only semicolon delimited values `(a;b;c)`
// or even only semicolons with single dangling commas `(a,;b,;c,)`
// it is not treated as a tuple, but as an inline block.
// Thanks to `~tuple-vs-parens` lezer will try both and resort to inline block if it can.
// (TODO I don't like this exception!!)
inner_paren {
  (expression | AssignmentExpression)
  ~tuple-vs-parens
  (";"+ (expression | AssignmentExpression) ","?)*
  ";"*
}
ParenthesizedExpression[@dynamicPrecedence=1] {
  "(" inner_paren ")"
}
GeneratorExpression {
  "(" ListCompherension !single-is-special ")"
}

// This shouldn't have tuple semantics,
// but matrix/array semantics!
DiscontinuedVector {
  "{" inner_tuple "}"
}

//////////////
// Macros!
/////////////

MacroExpression[@dynamicPrecedence=10] {
  (MacroIdentifier | MacroFieldExpression)
  (
    with_parens[@dynamicPrecedence=1] {
      // @use_memo([]) do; ... end
      !macro ArgumentList
    } | 
    with_typed_arguments[@dynamicPrecedence=1] {
       // @NamedTuple{x::Int}
      !macro ImmediateTypeArgumentList
    } |
    !macro MacroArgumentList // Lame, normal macro call pfffft
  )?
}

MacroFieldExpression {
  expression !immediate immediate_dot MacroIdentifier  |
  MacroIdentifier !immediate immediate_dot Identifier
}

MacroIdentifier {
  "@" MacroName { 
    word |
    Operator |
    // These two aren't allowed as normal operators,
    // but are allowed as macro names ðŸ¤·â€â™€ï¸
    // TODO ".." should be here too, but conflicts with `import ..X`
    Operator[group="operator"] { "." }
  }
}

MacroArgumentList {
  (!macro-argument statement)+
}

FunctionExpression {
  ArgumentList { !arrow expression !arrow }
  !arrow
  "->"
  !arrow
  (expression | AssignmentExpression)
}

contains_operator { kw<"in"> | kw<"isa"> }
// Needs `ternary2` so it can also match ` : `
// (Else just `a : b` freaks out)
colon_operator { ":" | immediate_colon | symbol_start | ternary2 }

// So turns out that if I remove all these and use
// `BinaryExpression { expression !plus "$" expression }`
// only, it about halves the time to generate...
// Just the fact there is so many tokens might overwhelm lezer..
// Maybe switch to ExternalTokenizer here too?
BinaryExpression {
  expression !power powerOperator expression |
  expression !bitshift bitshiftOperator expression |
  expression !pair pairOperator expression |
  // TODO Ideally we have ".." here too, but it causes too much
  // .... headaches to combine it with imports >_>
  // expression !colon (colon_operator | "..") expression |
  expression !colon (colon_operator) expression |
  expression !times timesOperator expression |
  expression !plus plusOperator expression |
  expression !plus_but_sometimes_interpolation "$" expression |
  expression !arrow arrowOperator expression |
  expression !pipeback pipe_ltr expression |
  expression !pipe pipe_rtl expression |
  expression !contains (contains_operator | comparisonOperator) expression |
  expression !bor "||" expression |
  expression !band "&&" expression
}

UnaryExpression {
  OperatorInUnaryExpression[@name=Operator] { unaryOperatorExtra | plusminus } ~op !unary expression
}

Operator[group="operator"] {
  // !regular0 (    
    "$" |
    bitshiftOperator |
    unaryOperatorExtra |
    plusOperator |
    timesOperator |
    powerOperator |
    comparisonOperator |
    arrowOperator |
    contains_operator |
    pipe_ltr |
    pipe_rtl |
    colon_operator
  // )
}

ArrayExpression {
  "[" "]" |
  "[" expression !array ("," expression)* (",")? "]"
}

// I have this defined in tokens as well...
// Not sure which is better, having the semicolons as one token
// or as x semicolon tokens.
// semicolons_without_spaces[@name="Semicolons"] { ";" (nowhitespace ";")* }

MatrixExpression{
  "["
  !regular-1
  MatrixRow
  (semicolons_without_spaces MatrixRow)* 
  semicolons_without_spaces?
  !regular-1
  "]"
}

// This is SO STUPID but because I love being extremely complete...
// Julia allows `[;;;]` but only if there is nothing between the semicolons,
// no expressions, no commas, no spaces, NO NOTHING
MatrixExpressionWithOnlySemicolons {
  "[" semicolons_without_spaces "]"
}

MatrixRow {
  (!matrix expression)+
}

ArrayComprehensionExpression {
  "[" !array-comprehension expression !array-comprehension comprehensionClause "]"
}

comprehensionClause {
  ForClause (ForClause | IfClause)*
}

IfClause {
  kw<"if"> expression
}

ForClause {
    kw<"for"> ForBinding (!forbinding "," ForBinding)*
}

ForBinding {
  expression AssignOperator { !immediate kw<"in"> | operator<"="> | operator<"âˆˆ"> } expression
}

// Even though it is technically "just an unary expression",
// I'm keeping this separate because it needs immediate_single_quote
// and because I don't feel like rewriting tests
TransposeExpression {
  expression !transpose immediate_single_quote
}

@skip {} {
  String {
    '"' (stringContent | Interpolation)* '"'
  }
  TripleString {
    '"""' (tripleStringContent | Interpolation)* '"""'
  }
  CommandString {
    "`" (commandStringContent | Interpolation)* "`"
  }

  StringWithoutInterpolation[@name=] {
    stringContentWithoutInterpolation '"'
  }
  TripleStringWithoutInterpolation[@name=] {
    tripleStringContentWithoutInterpolation '"""'
  }
  CommandStringWithoutInterpolation[@name=] {
    commandStringContentWithoutInterpolation "`"
  }
}

Interpolation {
  "$" Identifier |
  interpolationStart expression interpolationEnd
}

// Removed PrefixFieldExpression because it was grabbing things away from normal FieldExpressions
// PrefixFieldExpression[@name=FieldExpressionFake] {
//   (Identifier | PrefixFieldExpression)
//   !right-2 immediateDot !dot "." !dot
//   FieldName
// }
PrefixedString {
  Prefix { expression !prefix }
  (
    String { immediate_quote StringWithoutInterpolation } |
    String { immediate_triple_quote TripleStringWithoutInterpolation } |
    String { immediate_back_quote CommandStringWithoutInterpolation }
  )
  // Suffix { !suffix Suffix }?
}

operator<term> { [@name={term},group="operator"]{ term } } 
kw<term> { @specialize[@name={term},group="keyword"]<Identifier, term> }
blockkw<term, cc> { @specialize[@name={term},closedBy={cc},group="keyword"]<Identifier, term> }
boolean { @specialize[@name=BooleanLiteral]<Identifier, "true" | "false"> }

@context trackIsIndexing from "./begindexing.tokens.js"
@external specialize {Identifier} begin_end_but_cool from "./begindexing.tokens.js" {
  begin[@name="begin", group="keyword", closedBy="end"]
  BeginIndex
  end[@name="end", group="keyword", openedBy="quote begin if else elseif let try catch finally for while do function struct macro module baremodule struct mutable_struct abstract_type primitive_type"]
  EndIndex
}

// This needs to be above the other immediate_x tokens,
// specifically `immediate_paren`
@external tokens nowhitespace from "./index.tokens.js" {
  // ONLY USE FOR COEFFECIENT!!!
  // This is a very isolated case, just after numbers or tranpose, which is okay for now.
  // Ideally, think of a way to make it without nowhitespace
  nowhitespace
}
@external tokens layoutExtra from "./index.tokens.js" {
  immediate_dot[@name="."]
  
  immediate_brace[@name="{"]
  immediate_paren[@name="("]
  immediate_bracket[@name="["]
  immediate_colon[@name=":"]
  
  immediate_quote[@name="\""]
  immediate_triple_quote[@name="\"\"\""]
  immediate_back_quote[@name="`"]
  immediate_single_quote[@name="'"]

  interpolation_start[@name="$"]
  symbol_start[@name=":"]
}

terminator[@export="terminator"] { newline | ";" }

@external tokens newline from "./index.tokens.js" { newline }

@external tokens BlockComment from "./index.tokens.js" { BlockComment }

@external tokens tripleStringContent from "./index.tokens.js" { tripleStringContent }
@external tokens stringContent from "./index.tokens.js" { stringContent }
@external tokens commandStringContent from "./index.tokens.js" { commandStringContent }
@external tokens tripleStringContentWithoutInterpolation from "./index.tokens.js" { tripleStringContentWithoutInterpolation }
@external tokens stringContentWithoutInterpolation from "./index.tokens.js" { stringContentWithoutInterpolation }
@external tokens commandStringContentWithoutInterpolation from "./index.tokens.js" { commandStringContentWithoutInterpolation }

// @external tokens operators from "./all_these_operators.tokens.js" {
//   comparisonOperator,
//   arrowOperator,
//   timesOperator,
//   plusOperatorExtra,
//   powerOperator
// } 

plusOperator {
  plusOperatorExtra | plusminus
}

@tokens {
  // These are to export them to the begindexing context tracker
  "["[@export="BracketL"] 
  "]"[@export="BracketR"] 

  // Can implement strings in pure-lezer too?
  // Still have this commented out because feels odd that it works...
  // Also fixed the ExternalTokenizer so no need to fix this yet.
  // @precedence {
  //   "$"
  //   "\"\"\""
  //   stringContent
  //   tripleStringContent
  // }
  // stringContent {
  //   (![\\"$] | "\\" _ | "$" @whitespace)+
  // }
  // tripleStringContent {
  //   (![\\"$] | "\\" _ | "$" @whitespace | "\"" ![\\"$] | "\"" "\"" ![\\"$])+
  // }
  // stringContentWithoutInterpolation {
  //   (![\\"] | "\\" _)+
  // }

  whitespace {
    " " | "\t" | "\n"
  }
  Comment {
    "#" ![\n]*
  }
  Number {
    (
      "0" $[xX] $[0-9a-fA-F] $[0-9a-fA-F_]* |
      $[0-9] $[0-9_]* "."? ($[0-9] $[0-9_]*)? |
      "." $[0-9] $[0-9_]*
    )
    ($[eE] ("-" | "+")? $[0-9]+)?
  }
  powerOperator {
    "."? ("^" | "â†‘" | "â†“" | "â‡µ" | "âŸ°" | "âŸ±" | "â¤ˆ" | "â¤‰" | "â¤Š" | "â¤‹" | "â¤’" | "â¤“" | "â¥‰" | "â¥Œ" | "â¥" | "â¥" | "â¥‘" | "â¥”" | "â¥•" | "â¥˜" | "â¥™" | "â¥œ" | "â¥" | "â¥ " | "â¥¡" | "â¥£" | "â¥¥" | "â¥®" | "â¥¯" | "ï¿ª" | "ï¿¬")
  }
  timesOperator {
    "."? ("*" | "/" | "Ã·" | "%" | "&" | "â‹…" | "âˆ˜" | "Ã—" | "\\" | "âˆ©" | "âˆ§" | "âŠ—" | "âŠ˜" | "âŠ™" | "âŠš" | "âŠ›" | "âŠ " | "âŠ¡" | "âŠ“" | "âˆ—" | "âˆ™" | "âˆ¤" | "â…‹" | "â‰€" | "âŠ¼" | "â‹„" | "â‹†" | "â‹‡" | "â‹‰" | "â‹Š" | "â‹‹" | "â‹Œ" | "â‹" | "â‹’" | "âŸ‘" | "â¦¸" | "â¦¼" | "â¦¾" | "â¦¿" | "â§¶" | "â§·" | "â¨‡" | "â¨°" | "â¨±" | "â¨²" | "â¨³" | "â¨´" | "â¨µ" | "â¨¶" | "â¨·" | "â¨¸" | "â¨»" | "â¨¼" | "â¨½" | "â©€" | "â©ƒ" | "â©„" | "â©‹" | "â©" | "â©Ž" | "â©‘" | "â©“" | "â©•" | "â©˜" | "â©š" | "â©œ" | "â©ž" | "â©Ÿ" | "â© " | "â«›" | "âŠ" | "â–·" | "â¨" | "âŸ•" | "âŸ–" | "âŸ—")
  }
  plusOperatorExtra {
    "."? ("|||" | "âŠ•" | "âŠ–" | "âŠž" | "âŠŸ" | "|++|" | "âˆª" | "âˆ¨" | "âŠ”" | "Â±" | "âˆ“" | "âˆ”" | "âˆ¸" | "â‰" | "âŠŽ" | "âŠ»" | "âŠ½" | "â‹Ž" | "â‹“" | "â§º" | "â§»" | "â¨ˆ" | "â¨¢" | "â¨£" | "â¨¤" | "â¨¥" | "â¨¦" | "â¨§" | "â¨¨" | "â¨©" | "â¨ª" | "â¨«" | "â¨¬" | "â¨­" | "â¨®" | "â¨¹" | "â¨º" | "â©" | "â©‚" | "â©…" | "â©Š" | "â©Œ" | "â©" | "â©" | "â©’" | "â©”" | "â©–" | "â©—" | "â©›" | "â©" | "â©¡" | "â©¢" | "â©£")
  }
  arrowOperator {
    "."?  ("-->" | "â†" | "â†’" | "â†”" | "â†š" | "â†›" | "â†ž" | "â† " | "â†¢" | "â†£" | "â†¦" | "â†¤" | "â†®" | "â‡Ž" | "â‡" | "â‡" | "â‡" | "â‡’" | "â‡”" | "â‡´" | "â‡¶" | "â‡·" | "â‡¸" | "â‡¹" | "â‡º" | "â‡»" | "â‡¼" | "â‡½" | "â‡¾" | "â‡¿" | "âŸµ" | "âŸ¶" | "âŸ·" | "âŸ¹" | "âŸº" | "âŸ»" | "âŸ¼" | "âŸ½" | "âŸ¾" | "âŸ¿" | "â¤€" | "â¤" | "â¤‚" | "â¤ƒ" | "â¤„" | "â¤…" | "â¤†" | "â¤‡" | "â¤Œ" | "â¤" | "â¤Ž" | "â¤" | "â¤" | "â¤‘" | "â¤”" | "â¤•" | "â¤–" | "â¤—" | "â¤˜" | "â¤" | "â¤ž" | "â¤Ÿ" | "â¤ " | "â¥„" | "â¥…" | "â¥†" | "â¥‡" | "â¥ˆ" | "â¥Š" | "â¥‹" | "â¥Ž" | "â¥" | "â¥’" | "â¥“" | "â¥–" | "â¥—" | "â¥š" | "â¥›" | "â¥ž" | "â¥Ÿ" | "â¥¢" | "â¥¤" | "â¥¦" | "â¥§" | "â¥¨" | "â¥©" | "â¥ª" | "â¥«" | "â¥¬" | "â¥­" | "â¥°" | "â§´" | "â¬±" | "â¬°" | "â¬²" | "â¬³" | "â¬´" | "â¬µ" | "â¬¶" | "â¬·" | "â¬¸" | "â¬¹" | "â¬º" | "â¬»" | "â¬¼" | "â¬½" | "â¬¾" | "â¬¿" | "â­€" | "â­" | "â­‚" | "â­ƒ" | "â­„" | "â­‡" | "â­ˆ" | "â­‰" | "â­Š" | "â­‹" | "â­Œ" | "ï¿©" | "ï¿«" | "â‡œ" | "â‡" | "â†œ" | "â†" | "â†©" | "â†ª" | "â†«" | "â†¬" | "â†¼" | "â†½" | "â‡€" | "â‡" | "â‡„" | "â‡†" | "â‡‡" | "â‡‰" | "â‡‹" | "â‡Œ" | "â‡š" | "â‡›" | "â‡ " | "â‡¢")
  }
  bitshiftOperator {
    "."? (">>" | "<<" | ">>>")
  }
  pairOperator {
    "."? "=>"
  }
  comparisonOperator {
    "."?  ("<:" | ">" | "<" | ">=" | "â‰¥" | "<=" | "â‰¤" | "==" | "===" | "â‰¡" | "!=" | "â‰ " | "!==" | "â‰¢" | "âˆˆ" | "âˆ‰" | "âˆ‹" | "âˆŒ" | "âŠ†" | "âŠˆ" | "âŠ‚" | "âŠ„" | "âŠŠ" | "âˆ" | "âˆŠ" | "âˆ" | "âˆ¥" | "âˆ¦" | "âˆ·" | "âˆº" | "âˆ»" | "âˆ½" | "âˆ¾" | "â‰" | "â‰ƒ" | "â‰‚" | "â‰„" | "â‰…" | "â‰†" | "â‰‡" | "â‰ˆ" | "â‰‰" | "â‰Š" | "â‰‹" | "â‰Œ" | "â‰" | "â‰Ž" | "â‰" | "â‰‘" | "â‰’" | "â‰“" | "â‰–" | "â‰—" | "â‰˜" | "â‰™" | "â‰š" | "â‰›" | "â‰œ" | "â‰" | "â‰ž" | "â‰Ÿ" | "â‰£" | "â‰¦" | "â‰§" | "â‰¨" | "â‰©" | "â‰ª" | "â‰«" | "â‰¬" | "â‰­" | "â‰®" | "â‰¯" | "â‰°" | "â‰±" | "â‰²" | "â‰³" | "â‰´" | "â‰µ" | "â‰¶" | "â‰·" | "â‰¸" | "â‰¹" | "â‰º" | "â‰»" | "â‰¼" | "â‰½" | "â‰¾" | "â‰¿" | "âŠ€" | "âŠ" | "âŠƒ" | "âŠ…" | "âŠ‡" | "âŠ‰" | "âŠ‹" | "âŠ" | "âŠ" | "âŠ‘" | "âŠ’" | "âŠœ" | "âŠ©" | "âŠ¬" | "âŠ®" | "âŠ°" | "âŠ±" | "âŠ²" | "âŠ³" | "âŠ´" | "âŠµ" | "âŠ¶" | "âŠ·" | "â‹" | "â‹" | "â‹‘" | "â‹•" | "â‹–" | "â‹—" | "â‹˜" | "â‹™" | "â‹š" | "â‹›" | "â‹œ" | "â‹" | "â‹ž" | "â‹Ÿ" | "â‹ " | "â‹¡" | "â‹¢" | "â‹£" | "â‹¤" | "â‹¥" | "â‹¦" | "â‹§" | "â‹¨" | "â‹©" | "â‹ª" | "â‹«" | "â‹¬" | "â‹­" | "â‹²" | "â‹³" | "â‹´" | "â‹µ" | "â‹¶" | "â‹·" | "â‹¸" | "â‹¹" | "â‹º" | "â‹»" | "â‹¼" | "â‹½" | "â‹¾" | "â‹¿" | "âŸˆ" | "âŸ‰" | "âŸ’" | "â¦·" | "â§€" | "â§" | "â§¡" | "â§£" | "â§¤" | "â§¥" | "â©¦" | "â©§" | "â©ª" | "â©«" | "â©¬" | "â©­" | "â©®" | "â©¯" | "â©°" | "â©±" | "â©²" | "â©³" | "â©µ" | "â©¶" | "â©·" | "â©¸" | "â©¹" | "â©º" | "â©»" | "â©¼" | "â©½" | "â©¾" | "â©¿" | "âª€" | "âª" | "âª‚" | "âªƒ" | "âª„" | "âª…" | "âª†" | "âª‡" | "âªˆ" | "âª‰" | "âªŠ" | "âª‹" | "âªŒ" | "âª" | "âªŽ" | "âª" | "âª" | "âª‘" | "âª’" | "âª“" | "âª”" | "âª•" | "âª–" | "âª—" | "âª˜" | "âª™" | "âªš" | "âª›" | "âªœ" | "âª" | "âªž" | "âªŸ" | "âª " | "âª¡" | "âª¢" | "âª£" | "âª¤" | "âª¥" | "âª¦" | "âª§" | "âª¨" | "âª©" | "âªª" | "âª«" | "âª¬" | "âª­" | "âª®" | "âª¯" | "âª°" | "âª±" | "âª²" | "âª³" | "âª´" | "âªµ" | "âª¶" | "âª·" | "âª¸" | "âª¹" | "âªº" | "âª»" | "âª¼" | "âª½" | "âª¾" | "âª¿" | "â«€" | "â«" | "â«‚" | "â«ƒ" | "â«„" | "â«…" | "â«†" | "â«‡" | "â«ˆ" | "â«‰" | "â«Š" | "â«‹" | "â«Œ" | "â«" | "â«Ž" | "â«" | "â«" | "â«‘" | "â«’" | "â«“" | "â«”" | "â«•" | "â«–" | "â«—" | "â«˜" | "â«™" | "â«·" | "â«¸" | "â«¹" | "â«º" | "âŠ¢" | "âŠ£" | "âŸ‚")
  }
  assignOperator {
    ":=" | "."? ("~" | "=" | "+=" | "-=" | "*=" | "/=" | "//=" | "|=|" | "^=" | "Ã·=" | "%=" | "<<=" | ">>=" | ">>>=" | "||=|" | "&=" | "âŠ»=" | "â‰”" | "â©´" | "â‰•")
  }
  unaryOperatorExtra {
    "."? (">:" | "!" | "~" | "Â¬" | "âˆš" | "âˆ›" | "âˆœ")
  }
  plusminus {
    "."? ("+" | "-" | "|")
  }
  Character {
    "'" ("\\" !['] | ![']) "'"
  }

  operator_token {
    bitshiftOperator |
    unaryOperatorExtra |
    plusOperator |
    timesOperator |
    powerOperator |
    comparisonOperator |
    arrowOperator |
    contains_operator |
    pipe_ltr |
    pipe_rtl |
    colon_operator
  }

  pipe_ltr[@name="pipe<"] { "<|" | ".<|" }
  pipe_rtl[@name="pipe>"] { "|>" | ".|>" }

  // semicolons_without_spaces[@name="Semicolons"] { ";"+ }
  semicolons_without_spaces { ";"+ }
  
  ternary1 {
    whitespace+ "?" whitespace+
  }
  ternary2 {
    whitespace+ ":" whitespace+
  }

  // TODO Uncomment this so these will actually show up
  // .... in the tree and not be hidden blegh
  "(" ")" "{" "}" "[" "]" ";" "," "..." "." "$" "@"

  "="

  "abstract type"[@name="abstract_type", group="keyword", closedBy="end"]
  "primitive type"[@name="primitive_type", group="keyword", closedBy="end"]
  "mutable struct"[@name="mutable_struct", group="keyword", closedBy="end"]

  quoteStart[@name=":(", closedBy=")"] { ":(" }
  quoteEnd[@name=")", openedBy=":("] { ")" }

  interpolationStart[@name="$(", closedBy=")"] { "$(" }
  interpolationEnd[@name=")", openedBy="$("] { ")" }
  
  @precedence {
    "||"
    plusOperator
  }
  @precedence {
    "âˆˆ"
    comparisonOperator
  }
  
  @precedence {
    Number,
    pipe_ltr,
    pipe_rtl,
    // <: and < will fight over who should be chosen,
    // and if possible it should always be <: (not gonna have a range expression with `<` sadly)
    "<:",
    unaryOperatorExtra
    comparisonOperator,
    "=",
    assignOperator,
    plusOperatorExtra,
    ".",
    ternary1,
    ternary2,
    whitespace
  }
}

// So this is a tricky one... to have `word` for fieldnames and symbols
// but `Identifier` for Identifiers *and keywords*, I now have two tokens that are generated the same way...
// The trick is having `word` earlier in this list, so when it has to chose between `word` or `Identifier`,
// it will always take the `word` first.
@external tokens word from "./index.tokens.js" { word }
@external tokens Identifier from "./index.tokens.js" { Identifier }


@external propSource juliaHighlighting from "./highlight.js"

@precedence {
  interpolation
  immediate
  symbol

  imports
  renamed-import @right

  subscript
  
  dot @left
  single-is-special
  unary
  postfix
  transpose
  typeonlyascription @left
  
  type-parameters
  typeascription @left
  where @left

  prefix
  call

  // https://docs.julialang.org/en/v1/manual/mathematical-operations/#Operator-Precedence-and-Associativity
  power @left
  coefficient
  bitshift @left
  times @left
  plus @left
  colon @left
  pipe @left
  pipeback @right
  contains @left
  band @right
  bor @right

  suffix
  
  ternary @right
  pair @right
  forbinding

  something-statement
  return

  array

  baretuple
  assign @right
  arrow @right

  macro-argument
  macro

  array-comprehension

  matrix

  for-statement
  statement @right

  right0 @right
} 

@top SourceFile {
  expressionList
}

// EXPRESSIONS

expression {  
  blocky_things |
  definition |
  MacroExpression | 
  FunctionExpression |
  // TODO Imports is slow!
  import_expressions |
  CallExpression |
  
  Identifier |
  boolean |
  Character |
  Number |
  Symbol |
  String |
  TripleString |
  CommandString |

  CoefficientExpression |
  UnaryExpression |
  BinaryExpression |
  TernaryExpression |
  
  SpreadExpression |
  Where |
  LonelyType |
  Operator |
  BeginIndex |
  EndIndex |

  InterpolationExpression |
  FieldExpression |
  TransposeExpression |
  QuoteExpression |
  PrefixedString |

  SubscriptExpression |
  TypedMatrixExpression |
  TypedArrayComprehensionExpression |
  
  // NOTE TupleExpression actually makes lezer generate FASTER?
  TupleExpression |
  GeneratorExpression |
  
  square_bracket_stuff |
  // NOTE Discontinued vector might/is still used by some macros
  // .... but it also adds a couple of seconds to the build...
  discontinued_vector_syntax |
  
  TypedExpression |
  ParameterizedIdentifier | 
  
  ParenthesizedExpression
}


@skip { whitespace | Comment | BlockComment }

// TOP LEVEL

expressionList {
  terminator*
  (
    statement
    (
      terminator+
      (!statement statement)
    )*
    terminator*
  )?
}

// # STATEMENTS
// AssignmentStatement and BareTuple are the only
// nodes that can only exist at the top level of blocks:
// Inside anything the BareTuple can't exist because it becomes
// a normal tuple, and assignment also can't have BareTuple inside
// so it become a AssignmentExpression instead.
statement {
  (expression | AssignmentStatement | BareTuple)
}
BareTuple {
  expression (!baretuple "," expression)+ 
}
// Wonderful how making this a whole separate thing works, but nesting it
// inside AssignmentStatement as `BareTuple ","?` does not ðŸ¤·â€â™€ï¸
BareTuple_with_comma[@name="BareTuple"] {
  expression (!baretuple "," expression)* ","
}
AssignmentStatement[@name="AssignmentExpression"] {  
  // So I finally think I understand what `!assign` here does:
  // Lezer is not sure if, before reduce-ing `Assignee`, it should parse
  // `@m x = 10` as `(@m x) = 10` or as `@m (x = 10)`.
  // By telling it just before the reduce "Hey, if you got here, take this
  // instead of something with a lower precedence" (e.g. a macro call),
  // we make sure lezer parses this correctly
  // Assignee {
    (expression | BareTuple | BareTuple_with_comma)
    !assign
  // }
  (assignOperator | "=")
  statement
}

AssignmentExpression {
  // Using `Assignee` here makes stuff like `c -> x = true` parse as
  // `(c -> x) = true` rather than `c -> (x = true)` ðŸ˜’
  expression
  !assign
  (assignOperator | "=")
  (expression | AssignmentExpression)
}

// BLOCKY THINGS

blocky_things {
  IfStatement |
  // IfStatement_Pro |
  TryCatchFinally |
  ForStatement |
  WhileStatement |
  LetStatement |
  ConstStatement |
  GlobalStatement |
  LocalStatement |
  QuoteStatement |
  BreakStatement |
  ContinueStatement |
  ReturnStatement |
  CompoundExpression
}

// IfStatement but with block matching working...
// Also creates a less readable tree, so
// TODO Look into how closedBy and openedBy is
// .... interpreted by the codemirror extension.
IfStatement_Pro {
  blockopen<"if", "else elseif end"> 
  IfClause { expression }
    expressionList
  (
    // TODO Should have openedBy="if elseif" too?
    blockcontinue<"elseif", "else elseif end">
    ElseIfClause { expression }
    expressionList
  )*
  (
    // TODO Should have openedBy "if elseif"?
    blockcontinue<"else", "end">
    ElseClause { expressionList }
  )?
  end
}

IfStatement {
  IfClause { blockopen<"if", "end"> expression }
    expressionList
  ElseifClause*
  ElseClause?
  end
}
ElseifClause {
  IfClause { kw<"elseif"> expression }
  expressionList
}
ElseClause {
  kw<"else">
  expressionList
}

TryCatchFinally[@name="TryStatement"] {
  blockopen<"try", "catch finally end">
  expressionList
  Catch?
  Finally?
  end
}
Catch[@name="CatchClause"] {
  blockcontinue<"catch", "finally end">
  (CatchBinding { Identifier } | terminator)
  expressionList
}
Finally[@name="FinallyClause"] {
  blockcontinue<"finally", "end">
  expressionList
}

ForStatement {
  !for-statement
  blockopen<"for", "end">
  ForBinding
  ("," ForBinding)*
  expressionList
  end
}

WhileStatement {
  blockopen<"while", "end"> WhileBinding { expression }
    expressionList
  end
}

BreakStatement {
  kw<"break">
}

ContinueStatement {
  kw<"continue">
}

ReturnStatement {
  kw<"return"> (!return statement)?
}

LetStatement {
  blockopen<"let", "end">
  LetBinding {
    (expression | AssignmentExpression)
    ("," (expression | AssignmentExpression))*
  }?
  terminator
  expressionList
  end
}

ConstStatement {
  kw<"const"> !something-statement AssignmentStatement
}

GlobalStatement {
  kw<"global"> !something-statement statement
}

LocalStatement {
  kw<"local"> !something-statement statement
}

QuoteStatement {
  blockopen<"quote", "end">
  expressionList
  end
}

/////////////////
// IMPORT STUFF
/////////////////

import_expressions {
  ImportStatement |
  ExportStatement
}

ImportStatement {
  (kw<"using"> | kw<"import">)
  (imports | SelectedImport)
}
ExportStatement {
  kw<"export"> import_identifier (!right0 "," import_identifier)*
}

dot { "." | immediate_dot }

import_identifier {
  MacroIdentifier |
  Operator |
  Identifier { word } |
  InterpolationExpression
}
import_path {
  import_identifier |
  ImportFieldExpression { import_path !macro dot import_identifier } |
  RelativeImport { dot import_path }
}
import {
  import_path |
  RenamedImport { import_path kw<"as"> import_identifier }
}
imports {
  import (!imports "," import)*
}
SelectedImport {
  import_path !renamed-import immediate_colon Imports { imports }
}

// DEFINITIONS

definition {
  PrimitiveDefinition |
  AbstractDefinition |
  StructDefinition |
  MutableStructDefinition |
  ModuleDefinition |
  BareModuleDefinition |
  MacroDefinition |
  FunctionDefinition
}
Definition { expression }
FunctionDefinition {
  blockopen<"function", "end"> Definition expressionList end
}
MacroDefinition {
  blockopen<"macro", "end"> Definition expressionList end
}
PrimitiveDefinition {
   "primitive type" Definition Number end
}
AbstractDefinition {
  "abstract type" Definition end
}
StructDefinition {
  blockopen<"struct", "end"> Definition expressionList end
}
MutableStructDefinition {
  "mutable struct" Definition expressionList end
}
ModuleDefinition {
  blockopen<"module", "end"> Definition expressionList end
}
BareModuleDefinition {
  blockopen<"baremodule", "end"> Definition expressionList end
}

ParameterizedIdentifier {
  expression
  !type-parameters
  TypeArgumentList
}
TypeArgumentList {
  immediate_brace inner_tuple "}"
}

FieldName { word }

FieldExpression {
  expression
  !immediate
  immediate_dot
  (FieldName | Symbol | QuoteExpression | InterpolationExpression)
}

begindex_start[@name="[",begindexing="["] { 
  immediate_bracket
}
begindex_end[@name="]",begindexing="]"] { 
  "]"
}

SubscriptExpression {
  expression
  !subscript
  begindex_start // [
  array_inner
  begindex_end // ]
}
TypedArrayComprehensionExpression {
  expression
  !subscript
  ArrayComprehensionExpression {
    begindex_start // [
    list_comprehension
    begindex_end // ]
  }
}
TypedMatrixExpression {
  expression
  !subscript
  MatrixExpression {
    begindex_start // [
    matrix_inner
    begindex_end // ]
  }
}

  // ArrayExpression { "[" array_inner? "]" } |
  // ArrayComprehensionExpression { "[" list_comprehension "]" } |
  // MatrixExpression { "[" matrix_inner "]" } |
  // // This is SO STUPID but because I love being extremely complete...
  // // Julia allows `[;;;]` but only if there is nothing between the semicolons,
  // // no expressions, no commas, no spaces, NO NOTHING
  // MatrixExpressionWithOnlySemicolons { "[" semicolons_without_spaces "]" }


SpreadExpression {
  expression !dot "..."
}

TernaryExpression {
  expression
  !ternary ternary1 !ternary
  expression
  !ternary ternary2 !ternary
  expression
}

TypedExpression {
  // Value { expression !typeascription }
  expression
  !typeascription
  (operator<"::"> | operator<"<:">)
  Type { !typeascription expression }
}

Where {
  expression
  !where
  kw<"where">
  Type { !where expression }
}

CompoundExpression {
  begin
    expressionList
  end
}

// TODO Has more edge cases:
// .... but `a'(a)` being `(a')(a)`
// .... or `(10)x` still being `10 * x`
// .... or `(x)x` being `x * x`
// .... but `(:d)x` being a syntax error?
// .... And a lot more most likely
CoefficientExpression {
  (Number | TransposeExpression)
  !coefficient
  Coefficient {
    // Need to investigate what `!coefficient` here does
    !coefficient nowhitespace expression |
    TupleInsideCoefficient[@name="TupleExpression"] {
      immediate_paren inner_tuple ")"
    } |
    ParenthesizedInsideCoefficient[@name="ParenthesizedExpression"] {
      immediate_paren inner_paren ")"
    }
  }
}

// @dynamicPrecedence is necessary to nudge `x()` to `CallExpression`
// instead of `Indentifier TupleExpression`
CallExpression[@dynamicPrecedence=1] {
  expression
  !call
  Dot[@name="BroadcastDot"] { immediate_dot }?
  ArgumentList
}

DoClause {
  blockopen<"do", "end"> 
  (
    DoClauseArguments { expression ("," expression)* } |
    terminator
  )
  expressionList
  end
}

list_comprehension {
  expression
  !forbinding
  ForClause {
    kw<"for"> ForBinding (!forbinding "," ForBinding)*
    // TODO Rename to `Filter`? :D
    Filter[@name="IfClause"] { kw<"if"> expression }*
  }+
}
ForBinding {
  expression
  AssignOperator { !immediate kw<"in"> | operator<"="> | operator<"âˆˆ"> }
  expression
}


LonelyType {
  (operator<"::"> | operator<"<:">)
  Type { !typeonlyascription expression }
}

//////////
// Quoting and interpolation
//////////
InterpolationExpression[@name="Interpolation", @dynamicPrecedence=10] {
  interpolationStart inner_paren interpolationEnd |
  interpolation_start !interpolation symbol_name |
  TupleExpression[@dynamicPrecedence=-1] {
    interpolationStart inner_tuple interpolationEnd
  }

}

Symbol {
  symbol_start !symbol symbol_name
}
symbol_name {
  Identifier { word } |
  Number |
  String |
  Operator |
  // So assign operators are special because you can't use them as
  // normal identifiers e.g. `+` is valid code, `+=` isn't, while `:+=` is!
  AssignOperatorAsSymbols[@name=Operator] { assignOperator }
}

QuoteExpression[@name=Quote,@dynamicPrecedence=10] {
  quoteStart inner_paren quoteEnd |
  // Prefer the inner_paren way
  TupleExpression[@dynamicPrecedence=-1] {
    quoteStart inner_tuple quoteEnd
  } |
  quoteStart AssignOperatorInSymbols[@name=Operator] { assignOperator | "=" } quoteEnd
}


////////////
// Tuples, arguments and ParenthesizedExpression
////////////
tuple_section {
  ListCompherension { list_comprehension } |
  (expression | AssignmentExpression)
  ~tuple-vs-parens
  (
    ("," (expression | AssignmentExpression))*
    ("," ListCompherension { list_comprehension }?)?
  )?
}
inner_tuple {
  tuple_section?
  // Calling this `Parameters` now for backwards compatibility...
  // but I feel like all inner_tuples in a TupleExpression should
  // be equal and just "inner" or something
  ((";")+ Parameters { tuple_section })*
  (";")*
}

TupleExpression {
  "(" inner_tuple ")"
}

ArgumentList {
  immediate_paren inner_tuple ")" 
  DoClause?
}

// When a tuple has one element `(a)`
// or only semicolon delimited values `(a;b;c)`
// or even only semicolons with single dangling commas `(a,;b,;c,)`
// it is not treated as a tuple, but as an inline block.
// Thanks to `~tuple-vs-parens` lezer will try both and resort to inline block if it can.
// (TODO I don't like this exception!!)
inner_paren {
  (expression | AssignmentExpression)
  ~tuple-vs-parens
  (";"+ (expression | AssignmentExpression) ","?)*
  ";"*
}
ParenthesizedExpression[@dynamicPrecedence=1] {
  "(" inner_paren ")"
}
GeneratorExpression {
  "(" list_comprehension !single-is-special ")"
}

//////////////
// Macros!
/////////////
MacroExpression[@dynamicPrecedence=10] {
  (MacroIdentifier | MacroFieldExpression)
  (    
    // @use_memo([]) do; ... end
    !immediate ArgumentList | 
    // @NamedTuple{x::Int}
    !immediate TypeArgumentList |
    // Lame, normal macro call pfffft
    MacroArgumentList { (!macro-argument statement)+ }
  )?
}

MacroFieldExpression {
  expression !immediate immediate_dot MacroIdentifier  |
  MacroIdentifier !immediate immediate_dot Identifier { word }
}

MacroIdentifier {
  "@" MacroName { 
    word |
    Operator |
    // These two aren't allowed as normal operators,
    // but are allowed as macro names ðŸ¤·â€â™€ï¸
    // TODO ".." should be here too, but conflicts with `import ..X`
    Operator[group="operator"] { "." }
  }
}

FunctionExpression {
  ArgumentList { !arrow expression !arrow }
  !arrow
  "->"
  !arrow
  (expression | AssignmentExpression)
}

contains_operator { kw<"in"> | kw<"isa"> }
// Needs `ternary2` so it can also match ` : `
// (Else just `a : b` freaks out)
colon_operator { ":" | immediate_colon | symbol_start | ternary2 }

// So turns out that if I remove all these and use
// `BinaryExpression { expression !plus "$" expression }`
// only, it about halves the time to generate...
// Just the fact there is so many tokens might overwhelm lezer..
// Maybe switch to ExternalTokenizer here too?
BinaryExpression {
  expression !power powerOperator expression |
  expression !bitshift bitshiftOperator expression |
  expression !pair pairOperator expression |
  // TODO Ideally we have ".." here too, but it causes too much
  // .... headaches to combine it with imports >_>
  // expression !colon (colon_operator | "..") expression |
  expression !colon colon_operator expression |
  expression !times timesOperator expression |
  expression !plus (plusOperator | "$") expression |
  expression !arrow arrowOperator expression |
  expression !pipeback pipe_ltr expression |
  expression !pipe pipe_rtl expression |
  expression !contains (contains_operator | comparisonOperator) expression |
  expression !bor "||" expression |
  expression !band "&&" expression
}

UnaryExpression {
  (unaryOperatorExtra | plusminus)
  !unary
  expression
}

Operator[group="operator"] {
  bitshiftOperator |
  unaryOperatorExtra |
  plusOperator |
  timesOperator |
  powerOperator |
  comparisonOperator |
  arrowOperator |
  contains_operator |
  pipe_ltr |
  pipe_rtl |
  interpolation_start |
  colon_operator
}

//////////////
// Everything inside square brackets (`[` and `]`)
/////////////
square_bracket_stuff {
  ArrayExpression { "[" array_inner? "]" } |
  ArrayComprehensionExpression { "[" list_comprehension "]" } |
  MatrixExpression { "[" matrix_inner "]" } |
  // This is SO STUPID but because I love being extremely complete...
  // Julia allows `[;;;]` but only if there is nothing between the semicolons,
  // no expressions, no commas, no spaces, NO NOTHING
  MatrixExpressionWithOnlySemicolons { "[" semicolons_without_spaces "]" }
}

matrix_inner {
  MatrixRow
  (terminator+ MatrixRow)* 
  terminator*
}
MatrixRow { (!matrix statement)+ }
array_inner {
  expression !array ("," !array expression)* (",")?
}

//////////////
// Everything inside braces (`{` and `}`)
// Which is the same as `[` and `]`
/////////////
discontinued_vector_syntax {
  OldVectorExpression { "{" array_inner? "}" } |
  OldVectorComprehensionExpression { "{" list_comprehension "}" } |
  OldMatrixExpression { "{" matrix_inner "}" } |
  OldMatrixExpressionWithOnlySemicolons { "{" semicolons_without_spaces "}" }
}



// Even though it is technically "just an unary expression",
// I'm keeping this separate because it needs immediate_single_quote
// and because I don't feel like rewriting tests
TransposeExpression {
  expression !transpose immediate_single_quote
}

@skip {} {
  String {
    '"' (stringContent | Interpolation)* '"'
  }
  TripleString {
    '"""' (tripleStringContent | Interpolation)* '"""'
  }
  CommandString {
    "`" (commandStringContent | Interpolation)* "`"
  }

  StringWithoutInterpolation[@name=] {
    stringContentWithoutInterpolation '"'
  }
  TripleStringWithoutInterpolation[@name=] {
    tripleStringContentWithoutInterpolation '"""'
  }
  CommandStringWithoutInterpolation[@name=] {
    commandStringContentWithoutInterpolation "`"
  }
}

Interpolation {
  "$" Identifier { word } |
  interpolationStart expression interpolationEnd
}

// Removed PrefixFieldExpression because it was grabbing things away from normal FieldExpressions
// PrefixFieldExpression[@name=FieldExpressionFake] {
//   (Identifier | PrefixFieldExpression)
//   !right-2 immediateDot !dot "." !dot
//   FieldName
// }
PrefixedString {
  Prefix { expression !prefix }
  (
    String { immediate_quote StringWithoutInterpolation } |
    TripleString { immediate_triple_quote TripleStringWithoutInterpolation } |
    CommandString { immediate_back_quote CommandStringWithoutInterpolation }
  )
  Suffix { nowhitespace word }?
}

operator<term> { [@name={term},group="operator"]{ term } } 
kw<term> { @specialize[@name={term},group="keyword"]<Identifier, term> }

blockopen<term, cc> {
  @specialize[
    @name={term},
    closedBy={cc},
    group="controlKeyword",
    begindexing="begin"
  ]<Identifier, term>
}
blockcontinue<term, cc> {
  @specialize[
    @name={term},
    closedBy={cc},
    group="controlKeyword"
  ]<Identifier, term>
}
boolean { @specialize[@name=BooleanLiteral]<Identifier, "true" | "false"> }

@context trackIsIndexing from "./begindexing.tokens.js"
@external prop begindexing from "./begindexing.tokens.js"
@external specialize {Identifier} begin_end_but_cool from "./begindexing.tokens.js" {
  begin[
    @name="begin",
    group="keyword",
    closedBy="end",
    begindexing="begin"
  ]
  BeginIndex
  end[
    @name="end",
    group="keyword",
    openedBy="quote begin if else elseif let try catch finally for while do function struct macro module baremodule struct mutable_struct abstract_type primitive_type",
    begindexing="end"
  ]
  EndIndex
}

// This needs to be above the other immediate_x tokens,
// specifically `immediate_paren`
@external tokens nowhitespace from "./index.tokens.js" {
  // ONLY USE FOR COEFFICIENT OR SUFFIX!!!
  // This is a very isolated case, just after numbers or tranpose, which is okay for now.
  // Ideally, think of a way to make it without nowhitespace
  nowhitespace
}
@external tokens layoutExtra from "./index.tokens.js" {
  immediate_dot[@name="."]
  
  immediate_brace[@name="{"]
  immediate_paren[@name="("]
  immediate_bracket[@name="["]
  immediate_colon[@name=":"]
  
  immediate_quote[@name="\""]
  immediate_triple_quote[@name="\"\"\""]
  immediate_back_quote[@name="`"]
  immediate_single_quote[@name="'"]

  interpolation_start[@name="$"]
  symbol_start[@name=":"]
}

terminator[@export="terminator"] { newline | semicolons_without_spaces }

@external tokens newline from "./index.tokens.js" { newline }

@external tokens BlockComment from "./index.tokens.js" { BlockComment }

@external tokens tripleStringContent from "./index.tokens.js" { tripleStringContent }
@external tokens stringContent from "./index.tokens.js" { stringContent }
@external tokens commandStringContent from "./index.tokens.js" { commandStringContent }
@external tokens tripleStringContentWithoutInterpolation from "./index.tokens.js" { tripleStringContentWithoutInterpolation }
@external tokens stringContentWithoutInterpolation from "./index.tokens.js" { stringContentWithoutInterpolation }
@external tokens commandStringContentWithoutInterpolation from "./index.tokens.js" { commandStringContentWithoutInterpolation }

plusOperator {
  plusOperatorExtra | plusminus
}

@tokens {
  // Can implement strings in pure-lezer too?
  // Still have this commented out because feels odd that it works...
  // Also fixed the ExternalTokenizer so no need to fix this yet.
  // @precedence {
  //   "$"
  //   "\"\"\""
  //   stringContent
  //   tripleStringContent
  // }
  // stringContent {
  //   (![\\"$] | "\\" _ | "$" @whitespace)+
  // }
  // tripleStringContent {
  //   (![\\"$] | "\\" _ | "$" @whitespace | "\"" ![\\"$] | "\"" "\"" ![\\"$])+
  // }
  // stringContentWithoutInterpolation {
  //   (![\\"] | "\\" _)+
  // }

  whitespace {
    " " | "\t" | "\n"
  }
  Comment {
    "#" ![\n]*
  }
  Number {
    (
      "0" $[xX] $[0-9a-fA-F] $[0-9a-fA-F_]* |
      $[0-9] $[0-9_]* "."? ($[0-9] $[0-9_]*)? |
      "." $[0-9] $[0-9_]*
    )
    ($[eE] ("-" | "+")? $[0-9]+)?
  }
  powerOperator[@name="^"] {
    "."? ("^" | "â†‘" | "â†“" | "â‡µ" | "âŸ°" | "âŸ±" | "â¤ˆ" | "â¤‰" | "â¤Š" | "â¤‹" | "â¤’" | "â¤“" | "â¥‰" | "â¥Œ" | "â¥" | "â¥" | "â¥‘" | "â¥”" | "â¥•" | "â¥˜" | "â¥™" | "â¥œ" | "â¥" | "â¥ " | "â¥¡" | "â¥£" | "â¥¥" | "â¥®" | "â¥¯" | "ï¿ª" | "ï¿¬")
  }
  timesOperator[@name="*"] {
    "."? ("*" | "/" | "Ã·" | "%" | "&" | "â‹…" | "âˆ˜" | "Ã—" | "\\" | "âˆ©" | "âˆ§" | "âŠ—" | "âŠ˜" | "âŠ™" | "âŠš" | "âŠ›" | "âŠ " | "âŠ¡" | "âŠ“" | "âˆ—" | "âˆ™" | "âˆ¤" | "â…‹" | "â‰€" | "âŠ¼" | "â‹„" | "â‹†" | "â‹‡" | "â‹‰" | "â‹Š" | "â‹‹" | "â‹Œ" | "â‹" | "â‹’" | "âŸ‘" | "â¦¸" | "â¦¼" | "â¦¾" | "â¦¿" | "â§¶" | "â§·" | "â¨‡" | "â¨°" | "â¨±" | "â¨²" | "â¨³" | "â¨´" | "â¨µ" | "â¨¶" | "â¨·" | "â¨¸" | "â¨»" | "â¨¼" | "â¨½" | "â©€" | "â©ƒ" | "â©„" | "â©‹" | "â©" | "â©Ž" | "â©‘" | "â©“" | "â©•" | "â©˜" | "â©š" | "â©œ" | "â©ž" | "â©Ÿ" | "â© " | "â«›" | "âŠ" | "â–·" | "â¨" | "âŸ•" | "âŸ–" | "âŸ—")
  }
  plusOperatorExtra[@name="âŠ•"] {
    "."? ("|" | "âŠ•" | "âŠ–" | "âŠž" | "âŠŸ" | "|++|" | "âˆª" | "âˆ¨" | "âŠ”" | "Â±" | "âˆ“" | "âˆ”" | "âˆ¸" | "â‰" | "âŠŽ" | "âŠ»" | "âŠ½" | "â‹Ž" | "â‹“" | "â§º" | "â§»" | "â¨ˆ" | "â¨¢" | "â¨£" | "â¨¤" | "â¨¥" | "â¨¦" | "â¨§" | "â¨¨" | "â¨©" | "â¨ª" | "â¨«" | "â¨¬" | "â¨­" | "â¨®" | "â¨¹" | "â¨º" | "â©" | "â©‚" | "â©…" | "â©Š" | "â©Œ" | "â©" | "â©" | "â©’" | "â©”" | "â©–" | "â©—" | "â©›" | "â©" | "â©¡" | "â©¢" | "â©£")
  }
  arrowOperator[@name="-->"] {
    "."?  ("-->" | "â†" | "â†’" | "â†”" | "â†š" | "â†›" | "â†ž" | "â† " | "â†¢" | "â†£" | "â†¦" | "â†¤" | "â†®" | "â‡Ž" | "â‡" | "â‡" | "â‡" | "â‡’" | "â‡”" | "â‡´" | "â‡¶" | "â‡·" | "â‡¸" | "â‡¹" | "â‡º" | "â‡»" | "â‡¼" | "â‡½" | "â‡¾" | "â‡¿" | "âŸµ" | "âŸ¶" | "âŸ·" | "âŸ¹" | "âŸº" | "âŸ»" | "âŸ¼" | "âŸ½" | "âŸ¾" | "âŸ¿" | "â¤€" | "â¤" | "â¤‚" | "â¤ƒ" | "â¤„" | "â¤…" | "â¤†" | "â¤‡" | "â¤Œ" | "â¤" | "â¤Ž" | "â¤" | "â¤" | "â¤‘" | "â¤”" | "â¤•" | "â¤–" | "â¤—" | "â¤˜" | "â¤" | "â¤ž" | "â¤Ÿ" | "â¤ " | "â¥„" | "â¥…" | "â¥†" | "â¥‡" | "â¥ˆ" | "â¥Š" | "â¥‹" | "â¥Ž" | "â¥" | "â¥’" | "â¥“" | "â¥–" | "â¥—" | "â¥š" | "â¥›" | "â¥ž" | "â¥Ÿ" | "â¥¢" | "â¥¤" | "â¥¦" | "â¥§" | "â¥¨" | "â¥©" | "â¥ª" | "â¥«" | "â¥¬" | "â¥­" | "â¥°" | "â§´" | "â¬±" | "â¬°" | "â¬²" | "â¬³" | "â¬´" | "â¬µ" | "â¬¶" | "â¬·" | "â¬¸" | "â¬¹" | "â¬º" | "â¬»" | "â¬¼" | "â¬½" | "â¬¾" | "â¬¿" | "â­€" | "â­" | "â­‚" | "â­ƒ" | "â­„" | "â­‡" | "â­ˆ" | "â­‰" | "â­Š" | "â­‹" | "â­Œ" | "ï¿©" | "ï¿«" | "â‡œ" | "â‡" | "â†œ" | "â†" | "â†©" | "â†ª" | "â†«" | "â†¬" | "â†¼" | "â†½" | "â‡€" | "â‡" | "â‡„" | "â‡†" | "â‡‡" | "â‡‰" | "â‡‹" | "â‡Œ" | "â‡š" | "â‡›" | "â‡ " | "â‡¢")
  }
  bitshiftOperator[@name=">>"] {
    "."? (">>" | "<<" | ">>>")
  }
  pairOperator[@name="=>"] {
    "."? "=>"
  }
  comparisonOperator[@name="=="] {
    "."?  ("<:" | ">" | "<" | ">=" | "â‰¥" | "<=" | "â‰¤" | "==" | "===" | "â‰¡" | "!=" | "â‰ " | "!==" | "â‰¢" | "âˆˆ" | "âˆ‰" | "âˆ‹" | "âˆŒ" | "âŠ†" | "âŠˆ" | "âŠ‚" | "âŠ„" | "âŠŠ" | "âˆ" | "âˆŠ" | "âˆ" | "âˆ¥" | "âˆ¦" | "âˆ·" | "âˆº" | "âˆ»" | "âˆ½" | "âˆ¾" | "â‰" | "â‰ƒ" | "â‰‚" | "â‰„" | "â‰…" | "â‰†" | "â‰‡" | "â‰ˆ" | "â‰‰" | "â‰Š" | "â‰‹" | "â‰Œ" | "â‰" | "â‰Ž" | "â‰" | "â‰‘" | "â‰’" | "â‰“" | "â‰–" | "â‰—" | "â‰˜" | "â‰™" | "â‰š" | "â‰›" | "â‰œ" | "â‰" | "â‰ž" | "â‰Ÿ" | "â‰£" | "â‰¦" | "â‰§" | "â‰¨" | "â‰©" | "â‰ª" | "â‰«" | "â‰¬" | "â‰­" | "â‰®" | "â‰¯" | "â‰°" | "â‰±" | "â‰²" | "â‰³" | "â‰´" | "â‰µ" | "â‰¶" | "â‰·" | "â‰¸" | "â‰¹" | "â‰º" | "â‰»" | "â‰¼" | "â‰½" | "â‰¾" | "â‰¿" | "âŠ€" | "âŠ" | "âŠƒ" | "âŠ…" | "âŠ‡" | "âŠ‰" | "âŠ‹" | "âŠ" | "âŠ" | "âŠ‘" | "âŠ’" | "âŠœ" | "âŠ©" | "âŠ¬" | "âŠ®" | "âŠ°" | "âŠ±" | "âŠ²" | "âŠ³" | "âŠ´" | "âŠµ" | "âŠ¶" | "âŠ·" | "â‹" | "â‹" | "â‹‘" | "â‹•" | "â‹–" | "â‹—" | "â‹˜" | "â‹™" | "â‹š" | "â‹›" | "â‹œ" | "â‹" | "â‹ž" | "â‹Ÿ" | "â‹ " | "â‹¡" | "â‹¢" | "â‹£" | "â‹¤" | "â‹¥" | "â‹¦" | "â‹§" | "â‹¨" | "â‹©" | "â‹ª" | "â‹«" | "â‹¬" | "â‹­" | "â‹²" | "â‹³" | "â‹´" | "â‹µ" | "â‹¶" | "â‹·" | "â‹¸" | "â‹¹" | "â‹º" | "â‹»" | "â‹¼" | "â‹½" | "â‹¾" | "â‹¿" | "âŸˆ" | "âŸ‰" | "âŸ’" | "â¦·" | "â§€" | "â§" | "â§¡" | "â§£" | "â§¤" | "â§¥" | "â©¦" | "â©§" | "â©ª" | "â©«" | "â©¬" | "â©­" | "â©®" | "â©¯" | "â©°" | "â©±" | "â©²" | "â©³" | "â©µ" | "â©¶" | "â©·" | "â©¸" | "â©¹" | "â©º" | "â©»" | "â©¼" | "â©½" | "â©¾" | "â©¿" | "âª€" | "âª" | "âª‚" | "âªƒ" | "âª„" | "âª…" | "âª†" | "âª‡" | "âªˆ" | "âª‰" | "âªŠ" | "âª‹" | "âªŒ" | "âª" | "âªŽ" | "âª" | "âª" | "âª‘" | "âª’" | "âª“" | "âª”" | "âª•" | "âª–" | "âª—" | "âª˜" | "âª™" | "âªš" | "âª›" | "âªœ" | "âª" | "âªž" | "âªŸ" | "âª " | "âª¡" | "âª¢" | "âª£" | "âª¤" | "âª¥" | "âª¦" | "âª§" | "âª¨" | "âª©" | "âªª" | "âª«" | "âª¬" | "âª­" | "âª®" | "âª¯" | "âª°" | "âª±" | "âª²" | "âª³" | "âª´" | "âªµ" | "âª¶" | "âª·" | "âª¸" | "âª¹" | "âªº" | "âª»" | "âª¼" | "âª½" | "âª¾" | "âª¿" | "â«€" | "â«" | "â«‚" | "â«ƒ" | "â«„" | "â«…" | "â«†" | "â«‡" | "â«ˆ" | "â«‰" | "â«Š" | "â«‹" | "â«Œ" | "â«" | "â«Ž" | "â«" | "â«" | "â«‘" | "â«’" | "â«“" | "â«”" | "â«•" | "â«–" | "â«—" | "â«˜" | "â«™" | "â«·" | "â«¸" | "â«¹" | "â«º" | "âŠ¢" | "âŠ£" | "âŸ‚")
  }
  assignOperator {
    ":=" | "."? ("~" | "+=" | "-=" | "*=" | "/=" | "//=" | "|=|" | "^=" | "Ã·=" | "%=" | "<<=" | ">>=" | ">>>=" | "||=|" | "&=" | "âŠ»=" | "â‰”" | "â©´" | "â‰•")
  }
  unaryOperatorExtra[@name="!"] {
    "."? (">:" | "!" | "~" | "Â¬" | "âˆš" | "âˆ›" | "âˆœ")
  }
  plusminus[@name="+"] {
    "."? ("+" | "-")
  }
  Character {
    "'" ("\\" !['] | ![']) "'"
  }

  pipe_ltr[@name="pipe<"] { "<|" | ".<|" }
  pipe_rtl[@name="pipe>"] { "|>" | ".|>" }

  // semicolons_without_spaces[@name="Semicolons"] { ";"+ }
  semicolons_without_spaces[@name=";"] { ";"+ }
  
  ternary1 {
    whitespace+ "?" whitespace+
  }
  ternary2 {
    whitespace+ ":" whitespace+
  }

  "(" ")" "{" "}" "[" "]"
  ";" "," "." "..." "$" "@" "\""

  "="

  "abstract type"[@name="abstract_type", group="keyword", closedBy="end", begindexing="begin"]
  "primitive type"[@name="primitive_type", group="keyword", closedBy="end", begindexing="begin"]
  "mutable struct"[@name="mutable_struct", group="keyword", closedBy="end", begindexing="begin"]

  quoteStart[@name=":(", closedBy=")"] { ":(" }
  quoteEnd[@name=")", openedBy=":("] { ")" }

  interpolationStart[@name="$(", closedBy=")"] { "$(" }
  interpolationEnd[@name=")", openedBy="$("] { ")" }
  
  @precedence {
    "âˆˆ"
    comparisonOperator // "<" and "!="
  }

  @precedence {
    ternary1
    ternary2
    whitespace
  }
  
  @precedence {
    Number,
    pipe_ltr,
    pipe_rtl,
    // <: and < will fight over who should be chosen,
    // and if possible it should always be <: (not gonna have a range expression with `<` sadly)
    "<:",
    unaryOperatorExtra // "!" and "~"
    comparisonOperator // "<" and "!="
    "="
    // TODO Make "~" it's own token so it can be 
    assignOperator // "~"
    plusOperatorExtra
    "."
    ternary1
    ternary2
    whitespace
  }
}

// So this is a tricky one... to have `word` for fieldnames and symbols
// but `Identifier` for Identifiers *and keywords*, I now have two tokens that are generated the same way...
// The trick is having `word` earlier in this list, so when it has to chose between `word` or `Identifier`,
// it will always take the `word` first.
@external tokens word from "./index.tokens.js" { word }
@external tokens Identifier from "./index.tokens.js" { Identifier }


@external propSource juliaHighlighting from "./highlight.js"

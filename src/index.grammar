@precedence {
  interp
  immediate
  symbol

  imports
  imports-2
  renamed-import @right

  subscript
  
  dot @left
  single-is-special
  unary
  postfix
  transpose
  typeonlyascription @left
  
  type-parameters
  typeascription @left
  where @left

  prefix
  call

  // https://docs.julialang.org/en/v1/manual/mathematical-operations/#Operator-Precedence-and-Associativity
  power @left
  coefficient
  bitshift @left
  times @left
  plus @left
  colon @left
  pipe @left
  pipeback @right
  contains @left
  band @right
  bor @right

  suffix
  
  ternary @right
  pair @right
  forbinding

  something-statement
  return

  baretuple
  assign @right
  arrow @right

  macro-argument
  macro

  array
  array-comprehension

  // This makes it so `[a $b]` is parsed correctly,
  // but it makes `[a $ b]` not work, sadly.
  // But I care more about the former 🤷‍♀️
  matrix
  plus_but_sometimes_interpolation @right

  for-statement
  statement @right

  right0 @right
  regular0
  regular-1
} 

@top SourceFile {
  expressionList
}

// EXPRESSIONS

expression {  
  blocky_things |
  definition |
  MacroExpression |
  FunctionExpression |
  CallExpression |

  // TODO Imports is slow!
  import_expressions |
  
  Identifier |
  boolean |
  Character |
  Number |
  String |
  Symbol |

  CoefficientExpression |
  UnaryExpression |
  BinaryExpression |
  TernaryExpression |
  
  SpreadExpression |
  Where |
  LonelyType |
  Operator ~op |
  BeginIndex |
  EndIndex |

  InterpolationExpression |
  FieldExpression |
  TransposeExpression |
  SubscriptExpression |
  QuoteExpression |
  TripleString |
  CommandString |
  PrefixedString |
  
  // NOTE TupleExpression actually makes lezer generate FASTER?
  TupleExpression |
  GeneratorExpression |
  ArrayExpression |
  ArrayComprehensionExpression |
  MatrixExpression |
  MatrixExpressionWithOnlySemicolons |
  
  // TODO Discontinued vector might/is still used by some macros
  // .... but it also adds a couple of seconds to the build...
  // .... So changed it for TypeArgumentList for now...
  // .... Not fully accurate, but acurate enough?
  TypeArgumentList |

  TypedExpression |
  ParameterizedIdentifier | 
  
  ParenthesizedExpression
}


@skip { whitespace | Comment | BlockComment }

// TOP LEVEL

expressionList {
  terminator*
  (
    statement
    (
      terminator+
      (!statement statement)
    )*
    terminator*
  )?
}

// # STATEMENTS
// AssignmentStatement and BareTuple are the only
// nodes that can only exist at the top level of blocks:
// Inside anything the BareTuple can't exist because it becomes
// a normal tuple, and assignment also can't have BareTuple inside
// so it become a AssignmentExpression instead.
statement {
  (expression | AssignmentStatement | BareTuple)
}
BareTuple {
  expression (!baretuple "," expression)+ 
}
// Wonderful how making this a whole separate thing works, but nesting it
// inside AssignmentStatement as `BareTuple ","?` does not 🤷‍♀️
BareTuple_with_comma[@name="BareTuple"] {
  expression (!baretuple "," expression)* ","
}
AssignmentStatement[@name="AssignmentExpression"] {  
  // So I finally think I understand what `!assign` here does:
  // Lezer is not sure if, before reduce-ing `Assignee`, it should parse
  // `@m x = 10` as `(@m x) = 10` or as `@m (x = 10)`.
  // By telling it just before the reduce "Hey, if you got here, take this
  // instead of something with a lower precedence" (e.g. a macro call),
  // we make sure lezer parses this correctly
  // Assignee {
    (expression | BareTuple | BareTuple_with_comma)
    !assign
  // }
  (assignOperator | "=")
  statement
}

AssignmentExpression {
  // Using `Assignee` here makes stuff like `c -> x = true` parse as
  // `(c -> x) = true` rather than `c -> (x = true)` 😒
  expression
  !assign
  (assignOperator | "=")
  (expression | AssignmentExpression)
}

// BLOCKY THINGS

blocky_things {
  IfStatement |
  // IfStatement_Pro |
  TryCatchFinally |
  ForStatement |
  WhileStatement |
  LetStatement |
  ConstStatement |
  GlobalStatement |
  LocalStatement |
  QuoteStatement |
  BreakStatement |
  ContinueStatement |
  ReturnStatement |
  CompoundExpression
}

// IfStatement but with block matching working...
// Also creates a less readable tree, so
// TODO Look into how closedBy and openedBy is
// .... interpreted by the codemirror extension.
IfStatement_Pro {
  blockkw<"if", "else elseif end"> 
  IfClause { expression }
    expressionList
  (
    // TODO Should have openedBy="if elseif" too?
    blockkw<"elseif", "else elseif end">
    ElseIfClause { expression }
    expressionList
  )*
  (
    // TODO Should have openedBy "if elseif"?
    blockkw<"else", "end">
    ElseClause { expressionList }
  )?
  end
}

IfStatement {
  IfClause { kw<"if"> expression }
    expressionList
  ElseifClause*
  ElseClause?
  end
}
ElseifClause {
  IfClause { kw<"elseif"> expression }
  expressionList
}
ElseClause {
  kw<"else">
  expressionList
}

TryCatchFinally[@name="TryStatement"] {
  blockkw<"try", "catch finally end">
  expressionList
  Catch?
  Finally?
  end
}
Catch[@name="CatchClause"] {
  blockkw<"catch", "finally end">
  (CatchBinding { Identifier } | terminator)
  expressionList
}
Finally[@name="FinallyClause"] {
  blockkw<"finally", "end">
  expressionList
}

// TODO Should the `in`s be closedBy/openedBy too?
ForStatement {
  !for-statement
  blockkw<"for", "end">
  ForBinding
  ("," ForBinding)*
  expressionList
  end
}

WhileStatement {
  blockkw<"while", "end"> WhileBinding { expression }
    expressionList
  end
}

BreakStatement {
  kw<"break">
}

ContinueStatement {
  kw<"continue">
}

ReturnStatement {
  // kw<"return"> (!return statement)? terminator
  kw<"return"> (!return statement)?
}

LetStatement {
  blockkw<"let", "end">
  LetBinding {
    (expression | AssignmentExpression)
    ("," (expression | AssignmentExpression))*
  }?
  terminator
  expressionList
  end
}

ConstStatement {
  kw<"const"> !something-statement AssignmentStatement
}

GlobalStatement {
  kw<"global"> !something-statement statement
}

LocalStatement {
  kw<"local"> !something-statement statement
}

QuoteStatement {
  blockkw<"quote", "end">
  expressionList
  end
}

/////////////////
// IMPORT STUFF
/////////////////

import_expressions {
  ImportStatement |
  ExportStatement
}

importable {
  Identifier |
  MacroIdentifier |
  Operator
}

ImportStatement {
  (kw<"using"> | kw<"import">)
  (Imports | SelectedImport)
}
ExportStatement {
  kw<"export"> importable (!right0 "," importable)*
}

dot { "." | immediate_dot }

Import {
  RelativeDots { !imports-2 (!imports-2 dot !imports-2)+ }?
  Property { importable !imports-2 dot }*
  // importable
  Name { importable }
  Rename { kw<"as"> importable }? 
}
Imports {
  Import (!imports "," Import)*
}
SelectedImport {
  Import !renamed-import immediate_colon Imports
}

// DEFINITIONS

definition {
  PrimitiveDefinition |
  AbstractDefinition |
  StructDefinition |
  MutableStructDefinition |
  ModuleDefinition |
  BareModuleDefinition |
  MacroDefinition |
  FunctionDefinition
}
Definition { expression }
FunctionDefinition {
  !regular0 blockkw<"function", "end">
    Definition
    expressionList
  end
}
MacroDefinition {
  blockkw<"macro", "end"> Definition
    expressionList
  end
}

PrimitiveDefinition {
   "primitive type" Definition Number end
}

AbstractDefinition {
  "abstract type" Definition end
}

StructDefinition {
  blockkw<"struct", "end"> Definition
    expressionList
  end
}
MutableStructDefinition {
  "mutable struct"
  // blockkw<"mutable", "end"> blockkw<"struct", "end">
  Definition
    expressionList
  end
}


ModuleDefinition {
  blockkw<"module", "end"> Definition
    expressionList
  end
}

BareModuleDefinition {
  blockkw<"baremodule", "end"> Definition
    expressionList
  end
}

// @dynamicPrecedence to make this prefered over `Identifier TypeArgumentList`
ParameterizedIdentifier[@dynamicPrecedence=1] {
  expression
  !type-parameters
  ImmediateTypeArgumentList
}
ImmediateTypeArgumentList[@name="TypeArgumentList"] {
  immediate_brace inner_tuple "}"
}
TypeArgumentList {
  "{" inner_tuple "}"
}

FieldName { word }

FieldExpression {
  expression
  immediate_dot
  (FieldName | Symbol | QuoteExpression | InterpolationExpression)
}

begindex_start[@export="begindex_start"] { 
  immediate_bracket
}
begindex_end[@export="begindex_end"] { 
  "]"
}

SubscriptExpression {
  expression
  !subscript
  begindex_start // [
  inner_tuple
  begindex_end // ]
}

SpreadExpression {
  expression !dot "..."
}

TernaryExpression {
  expression
  !ternary ternary1 !ternary
  expression
  !ternary ternary2 !ternary
  expression
}

TypedExpression {
  // Value { expression !typeascription }
  expression
  !typeascription
  (operator<"::"> | operator<"<:">)
  Type { !typeascription expression }
}

Where {
  expression
  !where
  kw<"where">
  Type { !where expression }
}

CompoundExpression {
  begin
    expressionList
  end
}

// TODO Has more edge cases:
// .... but `a'(a)` being `(a')(a)`
// .... or `(10)x` still being `10 * x`
// .... or `(x)x` being `x * x`
// .... but `(:d)x` being a syntax error?
// .... And a lot more most likely
CoefficientExpression {
  (Number | TransposeExpression)
  !coefficient
  Coefficient {
    // Need to investigate what `!coefficient` here does
    !coefficient nowhitespace expression |
    ParenthesizedInsideCoefficient[@name="ParenthesizedExpression"] {
      immediate_paren inner_tuple ")"
    }
  }
}

// @dynamicPrecedence is necessary to nudge `x()` to `CallExpression`
// instead of `Indentifier TupleExpression`
CallExpression[@dynamicPrecedence=1] {
  expression
  !call
  Dot[@name="BroadcastDot"] { immediate_dot }?
  ArgumentList
}

DoClause {
  blockkw<"do", "end"> 
  (
    // Disabled this for now... broke a lot of odd things...
    // Like with `expression` here it parsed `asd::Vector{Bar}`
    // as `(asd::Vector){Bar}` but it should be (asd)::Vector{Bar}`
    // SO ODD!! WHAT DO DOCLAUSEARGUMENTS HAVE TO DO WITH THAT!
    //
    DoClauseArguments { expression ("," expression)* } |
    // DoClauseArguments { do_clause_argument ("," do_clause_argument)* } |
    terminator
  )
  expressionList
  end
}

ListCompherension {
  expression comprehensionClause
}


LonelyType {
  (operator<"::"> | operator<"<:">)
  Type { !typeonlyascription expression }
}

//////////
// Quoting and interpolation
//////////
InterpolationExpression[@name=Interpolation, @dynamicPrecedence=10] {
  interpolationStart expression interpolationEnd |
  // TODO Make this "$" also InterpolationStart?
  interpolation_start symbol_name
}

Symbol {
  // TODO Make this ":" also QuoteStart?
  symbol_start !symbol symbol_name
}
symbol_name {
  // The reason Symbol and QuoteExpression can co-exist is because
  // Symbol matches on `word`, which is just like identifier BUT
  // will match earlier... so Symbol will "snatch" all the
  // wordy symbols right from QuoteNode...
  // TODO Don't think this distinction is useful though
  Identifier { word } |
  Number |
  String |
  Operator |
  // So assign operators are special because you can't use them as
  // normal identifiers e.g. `+` is valid code, `+=` isn't, while `:+=` is!
  AssignOperatorAsSymbols[@name=Operator] { assignOperator }
  // TODO Allow all operators here explicitly so they get tagged as
  // .... Symbol rather than QuoteExpression (if we keep the distinction)
}

QuoteExpression[@name=Quote,@dynamicPrecedence=10] {
  quoteStart inner_paren quoteEnd |
  // Prefer the inner_paren way
  TupleExpression[@dynamicPrecedence=-1] {
    quoteStart inner_tuple quoteEnd
  } |
  quoteStart AssignOperatorInSymbols[@name=Operator] { assignOperator | "=" } quoteEnd
}


////////////
// Tuples, arguments and ParenthesizedExpression
////////////
tuple_section {
  (
    ListCompherension |
    (expression | AssignmentExpression)
    ~tuple-vs-parens
    (
      ("," (expression | AssignmentExpression))*
      ("," ListCompherension?)?
    )?
  )
}
inner_tuple {
  tuple_section?
  // Calling this `Parameters` now for backwards compatibility...
  // but I feel like all inner_tuples in a TupleExpression should
  // be equal and just "inner" or something
  ((";")+ Parameters { tuple_section })*
  (";")*
}

TupleExpression {
  "(" inner_tuple ")"
}

ArgumentList {
  immediate_paren inner_tuple ")" 
  DoClause?
}

// When a tuple has one element `(a)`
// or only semicolon delimited values `(a;b;c)`
// or even only semicolons with single dangling commas `(a,;b,;c,)`
// it is not treated as a tuple, but as an inline block.
// Thanks to `~tuple-vs-parens` lezer will try both and resort to inline block if it can.
// (TODO I don't like this exception!!)
inner_paren {
  (expression | AssignmentExpression)
  ~tuple-vs-parens
  (";"+ (expression | AssignmentExpression) ","?)*
  ";"*
}
ParenthesizedExpression[@dynamicPrecedence=1] {
  "(" inner_paren ")"
}
GeneratorExpression {
  "(" ListCompherension !single-is-special ")"
}

// This shouldn't have tuple semantics,
// but matrix/array semantics!
DiscontinuedVector {
  "{" inner_tuple "}"
}

//////////////
// Macros!
/////////////

MacroExpression[@dynamicPrecedence=10] {
  (MacroIdentifier | MacroFieldExpression)
  (
    with_parens[@dynamicPrecedence=1] {
      // @use_memo([]) do; ... end
      !macro ArgumentList
    } | 
    with_typed_arguments[@dynamicPrecedence=1] {
       // @NamedTuple{x::Int}
      !macro ImmediateTypeArgumentList
    } |
    !macro MacroArgumentList // Lame, normal macro call pfffft
  )?
}

MacroFieldExpression {
  expression !immediate immediate_dot MacroIdentifier  |
  MacroIdentifier !immediate immediate_dot Identifier
}

MacroIdentifier {
  "@" MacroName { 
    word |
    Operator |
    // These two aren't allowed as normal operators,
    // but are allowed as macro names 🤷‍♀️
    // TODO ".." should be here too, but conflicts with `import ..X`
    Operator[group="operator"] { "." }
  }
}

MacroArgumentList {
  (!macro-argument statement)+
}

FunctionExpression {
  ArgumentList { !arrow expression !arrow }
  !arrow
  "->"
  !arrow
  (expression | AssignmentExpression)
}

contains_operator { kw<"in"> | kw<"isa"> }
// Needs `ternary2` so it can also match ` : `
// (Else just `a : b` freaks out)
colon_operator { ":" | immediate_colon | symbol_start | ternary2 }

// So turns out that if I remove all these and use
// `BinaryExpression { expression !plus "$" expression }`
// only, it about halves the time to generate...
// Just the fact there is so many tokens might overwhelm lezer..
// Maybe switch to ExternalTokenizer here too?
BinaryExpression {
  expression !power powerOperator expression |
  expression !bitshift bitshiftOperator expression |
  expression !pair pairOperator expression |
  // TODO Ideally we have ".." here too, but it causes too much
  // .... headaches to combine it with imports >_>
  // expression !colon (colon_operator | "..") expression |
  expression !colon (colon_operator) expression |
  expression !times timesOperator expression |
  expression !plus plusOperator expression |
  expression !plus_but_sometimes_interpolation "$" expression |
  expression !arrow arrowOperator expression |
  expression !pipeback pipe_ltr expression |
  expression !pipe pipe_rtl expression |
  expression !contains (contains_operator | comparisonOperator) expression |
  expression !bor "||" expression |
  expression !band "&&" expression
}

UnaryExpression {
  OperatorInUnaryExpression[@name=Operator] { unaryOperatorExtra | plusminus } ~op !unary expression
}

Operator[group="operator"] {
  // !regular0 (    
    "$" |
    bitshiftOperator |
    unaryOperatorExtra |
    plusOperator |
    timesOperator |
    powerOperator |
    comparisonOperator |
    arrowOperator |
    contains_operator |
    pipe_ltr |
    pipe_rtl |
    colon_operator
  // )
}

ArrayExpression {
  "[" "]" |
  "[" expression !array ("," expression)* (",")? "]"
}

// I have this defined in tokens as well...
// Not sure which is better, having the semicolons as one token
// or as x semicolon tokens.
// semicolons_without_spaces[@name="Semicolons"] { ";" (nowhitespace ";")* }

MatrixExpression{
  "["
  !regular-1
  MatrixRow
  (semicolons_without_spaces MatrixRow)* 
  semicolons_without_spaces?
  !regular-1
  "]"
}

// This is SO STUPID but because I love being extremely complete...
// Julia allows `[;;;]` but only if there is nothing between the semicolons,
// no expressions, no commas, no spaces, NO NOTHING
MatrixExpressionWithOnlySemicolons {
  "[" semicolons_without_spaces "]"
}

MatrixRow {
  (!matrix expression)+
}

ArrayComprehensionExpression {
  "[" !array-comprehension expression !array-comprehension comprehensionClause "]"
}

comprehensionClause {
  ForClause (ForClause | IfClause)*
}

IfClause {
  kw<"if"> expression
}

ForClause {
    kw<"for"> ForBinding (!forbinding "," ForBinding)*
}

ForBinding {
  expression AssignOperator { !immediate kw<"in"> | operator<"="> | operator<"∈"> } expression
}

// Even though it is technically "just an unary expression",
// I'm keeping this separate because it needs immediate_single_quote
// and because I don't feel like rewriting tests
TransposeExpression {
  expression !transpose immediate_single_quote
}

@skip {} {
  String {
    '"' (stringContent | Interpolation)* '"'
  }
  TripleString {
    '"""' (tripleStringContent | Interpolation)* '"""'
  }
  CommandString {
    "`" (commandStringContent | Interpolation)* "`"
  }

  StringWithoutInterpolation[@name=] {
    stringContentWithoutInterpolation '"'
  }
  TripleStringWithoutInterpolation[@name=] {
    tripleStringContentWithoutInterpolation '"""'
  }
  CommandStringWithoutInterpolation[@name=] {
    commandStringContentWithoutInterpolation "`"
  }
}

Interpolation {
  "$" Identifier |
  interpolationStart expression interpolationEnd
}

// Removed PrefixFieldExpression because it was grabbing things away from normal FieldExpressions
// PrefixFieldExpression[@name=FieldExpressionFake] {
//   (Identifier | PrefixFieldExpression)
//   !right-2 immediateDot !dot "." !dot
//   FieldName
// }
PrefixedString {
  Prefix { expression !prefix }
  (
    String { immediate_quote StringWithoutInterpolation } |
    String { immediate_triple_quote TripleStringWithoutInterpolation } |
    String { immediate_back_quote CommandStringWithoutInterpolation }
  )
  // Suffix { !suffix Suffix }?
}

operator<term> { [@name={term},group="operator"]{ term } } 
kw<term> { @specialize[@name={term},group="keyword"]<Identifier, term> }
blockkw<term, cc> { @specialize[@name={term},closedBy={cc},group="keyword"]<Identifier, term> }
boolean { @specialize[@name=BooleanLiteral]<Identifier, "true" | "false"> }

@context trackIsIndexing from "./begindexing.tokens.js"
@external specialize {Identifier} begin_end_but_cool from "./begindexing.tokens.js" {
  begin[@name="begin", group="keyword", closedBy="end"]
  BeginIndex
  end[@name="end", group="keyword", openedBy="quote begin if else elseif let try catch finally for while do function struct macro module baremodule struct mutable_struct abstract_type primitive_type"]
  EndIndex
}

// This needs to be above the other immediate_x tokens,
// specifically `immediate_paren`
@external tokens nowhitespace from "./index.tokens.js" {
  // ONLY USE FOR COEFFECIENT!!!
  // This is a very isolated case, just after numbers or tranpose, which is okay for now.
  // Ideally, think of a way to make it without nowhitespace
  nowhitespace
}
@external tokens layoutExtra from "./index.tokens.js" {
  immediate_dot[@name="."]
  
  immediate_brace[@name="{"]
  immediate_paren[@name="("]
  immediate_bracket[@name="["]
  immediate_colon[@name=":"]
  
  immediate_quote[@name="\""]
  immediate_triple_quote[@name="\"\"\""]
  immediate_back_quote[@name="`"]
  immediate_single_quote[@name="'"]

  interpolation_start[@name="$"]
  symbol_start[@name=":"]
}

terminator[@export="terminator"] { newline | ";" }

@external tokens newline from "./index.tokens.js" { newline }

@external tokens BlockComment from "./index.tokens.js" { BlockComment }

@external tokens tripleStringContent from "./index.tokens.js" { tripleStringContent }
@external tokens stringContent from "./index.tokens.js" { stringContent }
@external tokens commandStringContent from "./index.tokens.js" { commandStringContent }
@external tokens tripleStringContentWithoutInterpolation from "./index.tokens.js" { tripleStringContentWithoutInterpolation }
@external tokens stringContentWithoutInterpolation from "./index.tokens.js" { stringContentWithoutInterpolation }
@external tokens commandStringContentWithoutInterpolation from "./index.tokens.js" { commandStringContentWithoutInterpolation }

// @external tokens operators from "./all_these_operators.tokens.js" {
//   comparisonOperator,
//   arrowOperator,
//   timesOperator,
//   plusOperatorExtra,
//   powerOperator
// } 

plusOperator {
  plusOperatorExtra | plusminus
}

@tokens {
  // These are to export them to the begindexing context tracker
  "["[@export="BracketL"] 
  "]"[@export="BracketR"] 

  // Can implement strings in pure-lezer too?
  // Still have this commented out because feels odd that it works...
  // Also fixed the ExternalTokenizer so no need to fix this yet.
  // @precedence {
  //   "$"
  //   "\"\"\""
  //   stringContent
  //   tripleStringContent
  // }
  // stringContent {
  //   (![\\"$] | "\\" _ | "$" @whitespace)+
  // }
  // tripleStringContent {
  //   (![\\"$] | "\\" _ | "$" @whitespace | "\"" ![\\"$] | "\"" "\"" ![\\"$])+
  // }
  // stringContentWithoutInterpolation {
  //   (![\\"] | "\\" _)+
  // }

  whitespace {
    " " | "\t" | "\n"
  }
  Comment {
    "#" ![\n]*
  }
  Number {
    (
      "0" $[xX] $[0-9a-fA-F] $[0-9a-fA-F_]* |
      $[0-9] $[0-9_]* "."? ($[0-9] $[0-9_]*)? |
      "." $[0-9] $[0-9_]*
    )
    ($[eE] ("-" | "+")? $[0-9]+)?
  }
  powerOperator {
    "."? ("^" | "↑" | "↓" | "⇵" | "⟰" | "⟱" | "⤈" | "⤉" | "⤊" | "⤋" | "⤒" | "⤓" | "⥉" | "⥌" | "⥍" | "⥏" | "⥑" | "⥔" | "⥕" | "⥘" | "⥙" | "⥜" | "⥝" | "⥠" | "⥡" | "⥣" | "⥥" | "⥮" | "⥯" | "￪" | "￬")
  }
  timesOperator {
    "."? ("*" | "/" | "÷" | "%" | "&" | "⋅" | "∘" | "×" | "\\" | "∩" | "∧" | "⊗" | "⊘" | "⊙" | "⊚" | "⊛" | "⊠" | "⊡" | "⊓" | "∗" | "∙" | "∤" | "⅋" | "≀" | "⊼" | "⋄" | "⋆" | "⋇" | "⋉" | "⋊" | "⋋" | "⋌" | "⋏" | "⋒" | "⟑" | "⦸" | "⦼" | "⦾" | "⦿" | "⧶" | "⧷" | "⨇" | "⨰" | "⨱" | "⨲" | "⨳" | "⨴" | "⨵" | "⨶" | "⨷" | "⨸" | "⨻" | "⨼" | "⨽" | "⩀" | "⩃" | "⩄" | "⩋" | "⩍" | "⩎" | "⩑" | "⩓" | "⩕" | "⩘" | "⩚" | "⩜" | "⩞" | "⩟" | "⩠" | "⫛" | "⊍" | "▷" | "⨝" | "⟕" | "⟖" | "⟗")
  }
  plusOperatorExtra {
    "."? ("|||" | "⊕" | "⊖" | "⊞" | "⊟" | "|++|" | "∪" | "∨" | "⊔" | "±" | "∓" | "∔" | "∸" | "≏" | "⊎" | "⊻" | "⊽" | "⋎" | "⋓" | "⧺" | "⧻" | "⨈" | "⨢" | "⨣" | "⨤" | "⨥" | "⨦" | "⨧" | "⨨" | "⨩" | "⨪" | "⨫" | "⨬" | "⨭" | "⨮" | "⨹" | "⨺" | "⩁" | "⩂" | "⩅" | "⩊" | "⩌" | "⩏" | "⩐" | "⩒" | "⩔" | "⩖" | "⩗" | "⩛" | "⩝" | "⩡" | "⩢" | "⩣")
  }
  arrowOperator {
    "."?  ("-->" | "←" | "→" | "↔" | "↚" | "↛" | "↞" | "↠" | "↢" | "↣" | "↦" | "↤" | "↮" | "⇎" | "⇍" | "⇏" | "⇐" | "⇒" | "⇔" | "⇴" | "⇶" | "⇷" | "⇸" | "⇹" | "⇺" | "⇻" | "⇼" | "⇽" | "⇾" | "⇿" | "⟵" | "⟶" | "⟷" | "⟹" | "⟺" | "⟻" | "⟼" | "⟽" | "⟾" | "⟿" | "⤀" | "⤁" | "⤂" | "⤃" | "⤄" | "⤅" | "⤆" | "⤇" | "⤌" | "⤍" | "⤎" | "⤏" | "⤐" | "⤑" | "⤔" | "⤕" | "⤖" | "⤗" | "⤘" | "⤝" | "⤞" | "⤟" | "⤠" | "⥄" | "⥅" | "⥆" | "⥇" | "⥈" | "⥊" | "⥋" | "⥎" | "⥐" | "⥒" | "⥓" | "⥖" | "⥗" | "⥚" | "⥛" | "⥞" | "⥟" | "⥢" | "⥤" | "⥦" | "⥧" | "⥨" | "⥩" | "⥪" | "⥫" | "⥬" | "⥭" | "⥰" | "⧴" | "⬱" | "⬰" | "⬲" | "⬳" | "⬴" | "⬵" | "⬶" | "⬷" | "⬸" | "⬹" | "⬺" | "⬻" | "⬼" | "⬽" | "⬾" | "⬿" | "⭀" | "⭁" | "⭂" | "⭃" | "⭄" | "⭇" | "⭈" | "⭉" | "⭊" | "⭋" | "⭌" | "￩" | "￫" | "⇜" | "⇝" | "↜" | "↝" | "↩" | "↪" | "↫" | "↬" | "↼" | "↽" | "⇀" | "⇁" | "⇄" | "⇆" | "⇇" | "⇉" | "⇋" | "⇌" | "⇚" | "⇛" | "⇠" | "⇢")
  }
  bitshiftOperator {
    "."? (">>" | "<<" | ">>>")
  }
  pairOperator {
    "."? "=>"
  }
  comparisonOperator {
    "."?  ("<:" | ">" | "<" | ">=" | "≥" | "<=" | "≤" | "==" | "===" | "≡" | "!=" | "≠" | "!==" | "≢" | "∈" | "∉" | "∋" | "∌" | "⊆" | "⊈" | "⊂" | "⊄" | "⊊" | "∝" | "∊" | "∍" | "∥" | "∦" | "∷" | "∺" | "∻" | "∽" | "∾" | "≁" | "≃" | "≂" | "≄" | "≅" | "≆" | "≇" | "≈" | "≉" | "≊" | "≋" | "≌" | "≍" | "≎" | "≐" | "≑" | "≒" | "≓" | "≖" | "≗" | "≘" | "≙" | "≚" | "≛" | "≜" | "≝" | "≞" | "≟" | "≣" | "≦" | "≧" | "≨" | "≩" | "≪" | "≫" | "≬" | "≭" | "≮" | "≯" | "≰" | "≱" | "≲" | "≳" | "≴" | "≵" | "≶" | "≷" | "≸" | "≹" | "≺" | "≻" | "≼" | "≽" | "≾" | "≿" | "⊀" | "⊁" | "⊃" | "⊅" | "⊇" | "⊉" | "⊋" | "⊏" | "⊐" | "⊑" | "⊒" | "⊜" | "⊩" | "⊬" | "⊮" | "⊰" | "⊱" | "⊲" | "⊳" | "⊴" | "⊵" | "⊶" | "⊷" | "⋍" | "⋐" | "⋑" | "⋕" | "⋖" | "⋗" | "⋘" | "⋙" | "⋚" | "⋛" | "⋜" | "⋝" | "⋞" | "⋟" | "⋠" | "⋡" | "⋢" | "⋣" | "⋤" | "⋥" | "⋦" | "⋧" | "⋨" | "⋩" | "⋪" | "⋫" | "⋬" | "⋭" | "⋲" | "⋳" | "⋴" | "⋵" | "⋶" | "⋷" | "⋸" | "⋹" | "⋺" | "⋻" | "⋼" | "⋽" | "⋾" | "⋿" | "⟈" | "⟉" | "⟒" | "⦷" | "⧀" | "⧁" | "⧡" | "⧣" | "⧤" | "⧥" | "⩦" | "⩧" | "⩪" | "⩫" | "⩬" | "⩭" | "⩮" | "⩯" | "⩰" | "⩱" | "⩲" | "⩳" | "⩵" | "⩶" | "⩷" | "⩸" | "⩹" | "⩺" | "⩻" | "⩼" | "⩽" | "⩾" | "⩿" | "⪀" | "⪁" | "⪂" | "⪃" | "⪄" | "⪅" | "⪆" | "⪇" | "⪈" | "⪉" | "⪊" | "⪋" | "⪌" | "⪍" | "⪎" | "⪏" | "⪐" | "⪑" | "⪒" | "⪓" | "⪔" | "⪕" | "⪖" | "⪗" | "⪘" | "⪙" | "⪚" | "⪛" | "⪜" | "⪝" | "⪞" | "⪟" | "⪠" | "⪡" | "⪢" | "⪣" | "⪤" | "⪥" | "⪦" | "⪧" | "⪨" | "⪩" | "⪪" | "⪫" | "⪬" | "⪭" | "⪮" | "⪯" | "⪰" | "⪱" | "⪲" | "⪳" | "⪴" | "⪵" | "⪶" | "⪷" | "⪸" | "⪹" | "⪺" | "⪻" | "⪼" | "⪽" | "⪾" | "⪿" | "⫀" | "⫁" | "⫂" | "⫃" | "⫄" | "⫅" | "⫆" | "⫇" | "⫈" | "⫉" | "⫊" | "⫋" | "⫌" | "⫍" | "⫎" | "⫏" | "⫐" | "⫑" | "⫒" | "⫓" | "⫔" | "⫕" | "⫖" | "⫗" | "⫘" | "⫙" | "⫷" | "⫸" | "⫹" | "⫺" | "⊢" | "⊣" | "⟂")
  }
  assignOperator {
    ":=" | "."? ("~" | "=" | "+=" | "-=" | "*=" | "/=" | "//=" | "|=|" | "^=" | "÷=" | "%=" | "<<=" | ">>=" | ">>>=" | "||=|" | "&=" | "⊻=" | "≔" | "⩴" | "≕")
  }
  unaryOperatorExtra {
    "."? (">:" | "!" | "~" | "¬" | "√" | "∛" | "∜")
  }
  plusminus {
    "."? ("+" | "-" | "|")
  }
  Character {
    "'" ("\\" !['] | ![']) "'"
  }

  operator_token {
    bitshiftOperator |
    unaryOperatorExtra |
    plusOperator |
    timesOperator |
    powerOperator |
    comparisonOperator |
    arrowOperator |
    contains_operator |
    pipe_ltr |
    pipe_rtl |
    colon_operator
  }

  pipe_ltr[@name="pipe<"] { "<|" | ".<|" }
  pipe_rtl[@name="pipe>"] { "|>" | ".|>" }

  // semicolons_without_spaces[@name="Semicolons"] { ";"+ }
  semicolons_without_spaces { ";"+ }
  
  ternary1 {
    whitespace+ "?" whitespace+
  }
  ternary2 {
    whitespace+ ":" whitespace+
  }

  // TODO Uncomment this so these will actually show up
  // .... in the tree and not be hidden blegh
  "(" ")" "{" "}" "[" "]" ";" "," "..." "." "$" "@"

  "="

  "abstract type"[@name="abstract_type", group="keyword", closedBy="end"]
  "primitive type"[@name="primitive_type", group="keyword", closedBy="end"]
  "mutable struct"[@name="mutable_struct", group="keyword", closedBy="end"]

  quoteStart[@name=":(", closedBy=")"] { ":(" }
  quoteEnd[@name=")", openedBy=":("] { ")" }

  interpolationStart[@name="$(", closedBy=")"] { "$(" }
  interpolationEnd[@name=")", openedBy="$("] { ")" }
  
  @precedence {
    "||"
    plusOperator
  }
  @precedence {
    "∈"
    comparisonOperator
  }
  
  @precedence {
    Number,
    pipe_ltr,
    pipe_rtl,
    // <: and < will fight over who should be chosen,
    // and if possible it should always be <: (not gonna have a range expression with `<` sadly)
    "<:",
    unaryOperatorExtra
    comparisonOperator,
    "=",
    assignOperator,
    plusOperatorExtra,
    ".",
    ternary1,
    ternary2,
    whitespace
  }
}

// So this is a tricky one... to have `word` for fieldnames and symbols
// but `Identifier` for Identifiers *and keywords*, I now have two tokens that are generated the same way...
// The trick is having `word` earlier in this list, so when it has to chose between `word` or `Identifier`,
// it will always take the `word` first.
@external tokens word from "./index.tokens.js" { word }
@external tokens Identifier from "./index.tokens.js" { Identifier }


@external propSource juliaHighlighting from "./highlight.js"

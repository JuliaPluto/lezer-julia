@precedence {
  immediate
  dot @left
  prefix
  postfix
  interp @left
  transpose
  typeonlyascription @left
  typeascription @left
  coeff
  call
  power @left
  bitshift @left
  times @left
  plus @left
  colon @left
  pipe @left
  pipeback @right
  contains @left
  band @right
  bor @right
  ternary @right
  pair @right
  forbinding
  baretuple
  assign @right
  arrow @right
  regular1
  right0 @right
  regular0
  regular-1
  right-2 @right
  regular-2
}

@top SourceFile {
  expressionList<e, pe> | ""
}

@skip { whitespace | Comment | BlockComment }

// TOP LEVEL
expressionList<e, pe> {
  terminator*
  (statement (terminator+ statement)* terminator*)?
}

// Statement, meaning this is only allowed inside blocks.
// The big difference between this and expressions is:
// `x,y = 1,2` (statement) yields `(x,y) = (1,2)`, but
// `(x,y = 1,2)` (expression) yields `x, (y = 1), 2`.
statement {
  // TODO Get rid of FunctionAssignmentExpression
  e ~id | BareTupleExpression<e> | AssignmentExpression<e> | FunctionAssignmentExpression
}

BareTupleExpression<e> {
  e (!baretuple "," e)+
}

AssignmentExpression<e> {
  (e | BareTupleExpression<e>)
  !assign (assignOperator | "=")
  (e | AssignmentExpression<e> | BareTupleExpression<e>)
}

FunctionAssignmentExpression[@dynamicPrecedence=2] {
  Identifier ~id immediateParen !call ArgumentList<e, pe> ~id
  (kw<"where"> TypeArgumentList<e>)?
  !assign (assignOperator | "=")
  !assign (e | AssignmentExpression<e>)
}

// STATEMENTS

blocks {
  IfStatement |
  TryStatement |
  ForStatement |
  WhileStatement |
  LetStatement |
  ConstStatement |
  GlobalStatement |
  LocalStatement |
  QuoteStatement |
  BreakStatement |
  ContinueStatement |
  ReturnStatement |
  ImportStatement |
  ExportStatement
}

IfStatement[closedBy="end else elseif"] {
  IfClause { kw<"if"> e }
    expressionList<e, pe>
  ElseifClause*
  ElseClause?
  end
}
ElseifClause[closedBy="end else elseif"] {
  IfClause { kw<"elseif"> e }
    expressionList<e, pe>
}
ElseClause[closedBy="end"] {
  kw<"else">
    expressionList<e, pe>
}

TryStatement[closedBy="end catch finally"] {
  kw<"try">
    expressionList<e, pe>
  CatchClause?
  FinallyClause?
  end
}
CatchClause[closedBy="end finally"] {
  kw<"catch"> CatchBinding { Identifier ~id }? !regular1
    expressionList<e, pe>
}
FinallyClause[closedBy="end"] {
  kw<"finally">
    expressionList<e, pe>
}

ForStatement[closedBy="end"] {
  !regular0 kw<"for"> ForBinding<e, pe> ("," ForBinding<e, pe>)*
    expressionList<e, pe>
  end
}

WhileStatement[closedBy="end"] {
  !regular0 kw<"while"> !regular0 WhileBinding { e } !regular0
    expressionList<e, pe>
  end
}

QuoteStatement[closedBy="end"] {
  kw<"quote"> !right-2
    expressionList<e, pe>
  end
}

BreakStatement { kw<"break"> }
ContinueStatement { kw<"continue"> }
ReturnStatement { kw<"return"> (!right-2 statement)? }
ConstStatement { kw<"const"> statement }
GlobalStatement { kw<"global"> statement }
LocalStatement { kw<"local"> statement }

LetStatement[closedBy="end"] {
  kw<"let"> LetBinding { list_expression<e> ("," list_expression<e>)* }? terminator
    expressionList<e, pe>
  end
}



ImportStatement {
  !right0 (kw<"using"> | kw<"import">)
  !right0 (Import | SelectedImport)
}

Import {
  (Identifier | ScopedIdentifier | RenamedIdentifier)
  (!right0 "," (Identifier | ScopedIdentifier | RenamedIdentifier))*
}

SelectedImport[@dynamicPrecedence=1] {
  (Identifier | ScopedIdentifier)
  !immediate immediateColon ":"
  list {
    (RenamedImport | Identifier | MacroIdentifier | Operator | Operator { "$" | ":" })
    (!right0 "," !right0 (RenamedImport | Identifier | MacroIdentifier | Operator))*
  }
}

RenamedIdentifier {
  (Identifier | ScopedIdentifier) kw<"as"> Identifier
}

RenamedImport {
  (Identifier | ScopedIdentifier | MacroIdentifier | Operator) kw<"as"> (Identifier | MacroIdentifier | Operator)
}

ExportStatement {
  kw<"export"> (Identifier | MacroIdentifier) (!right0 "," (Identifier | MacroIdentifier))*
}

// DEFINITIONS

definition {
  PrimitiveDefinition |
  AbstractDefinition |
  StructDefinition |
  ModuleDefinition |
  BareModuleDefinition |
  MacroDefinition |
  FunctionDefinition
}

CallWithoutDo[@name="CallExpression"] {
    pe
    !call immediateParen ~paren_after_expression
    !call call_without_do_args[@dynamicPrecedence=1] { ArgumentList<e, pe> }
}

FunctionDefinition[closedBy="end"] {
  !regular0
  kw<"function">
  Definition {
    TypedExpression<CallExpression<e, pe>> |
    // TypedExpression<CallWithoutDo> |
    CallWithoutDo |
    ArgumentList<e, pe> |
    Identifier ~id
  }
  (kw<"where"> TypeParameters { Identifier | TypeArgumentList<e> } )?
  expressionList<e, pe>
  end
}

MacroDefinition[closedBy="end"] {
  kw<"macro"> Definition { definitionHead } immediateParen ArgumentList<e, pe>
    expressionList<e, pe>
  end
}

ModuleDefinition[closedBy="end"] {
  kw<"module"> Definition { Identifier }
    expressionList<e, pe>
  end
}
BareModuleDefinition[closedBy="end"] {
  kw<"baremodule"> Definition { Identifier }
    expressionList<e, pe>
  end
}

PrimitiveDefinition[closedBy="end"] {
  kwe<"primitive"> kwe<"type"> Definition { pe } Number end
}
AbstractDefinition[closedBy="end"] {
  kwe<"abstract"> kwe<"type"> Definition { pe } end
}
StructDefinition[closedBy="end"] {
  kwe<"mutable">? kw<"struct"> Definition { pe } !regular0
    expressionList<e, pe>
  end
}

// TODO Get rid of this? Only used in MacroDefinition, and not
// .... sure if it is even useful to have there (lots of things are technically allowed in macro names)
definitionHead {
  InterpolationExpression |
  FieldExpression<definitionHead> |
  SubscriptExpression<definitionHead> |
  QuoteExpression |
  ParameterizedIdentifier<e, definitionHead> |
  Identifier ~id |
  ParenthesizedExpression<definitionHead> |
  Operator ~op
}

// EXPRESSIONS

e {
  blocks |
  definition |
  // TODO Move this into `blocks` when I got the `s_e` vs `CompoundExpression` things figured out
  CompoundExpression |
  // TODO Move this to pe? - Actually, move this to can-be-used-as-function-callee: `@x()()` is fine.
  MacroExpression<e, pe> |
  // TODO Move this to pe?
  UnaryExpression<e> |
  // TODO Move this to pe?
  BinaryExpression<e> |
  TernaryExpression<e> |
  FunctionExpression<e, pe> |
  // TODO Move this to pe?
  CoefficientExpression<e> |
  // TODO Move this to pe?
  TransposeExpression<e> |
  // TODO Move this to pe?
  SpreadExpression<e> |
  pe |

  // Can't be called ($() is interpolation) and `:()` is quoting,
  // but can be used as lonely operators `$`
  Operator { operator<"$"> | operator<":"> } |

  // Sad sad number belongs to `e` because you can't do `10()` or `10.x`
  Number
}

meta_programming<e, pe> {
  PrefixedString |
  MacroExpression<e, pe> |
  InterpolationExpression
}

// aka can-be-used-as-function-callee
// This means `pe()`, but also `pe.x`
pe {
  InterpolationExpression ~variabledeclaration |
  FieldExpression<pe> |
  SubscriptExpression<pe> |
  Symbol |
  QuoteExpression |
  CallExpression<e, pe> |
  Identifier ~id ~variabledeclaration |
  boolean |
  Character |
  String |
  TripleString |
  CommandString |
  PrefixedString |
  ParenthesizedExpression<e> |
  TupleExpression<e, pe> |
  ArrayExpression<e> |
  ArrayComprehensionExpression<e, pe> |
  MatrixExpression<e> |
  GeneratorExpression<e, pe> |
  TypedExpression<pe> |
  ParameterizedIdentifier<e, pe> |
  Operator ~op
}

// aka can-NOT-be-used-as-function-callee
// e.g. `$()` is interpolation, `:()` is quoting and `10()` is a coefficient
// But these are still valid in places where a lot of things aren't: `10{x}` is fine
uncallable {
  Operator { "$" | ":" } |
  Number
}

ParameterizedIdentifier<e, pe> {
  (pe | Number)
  !immediate immediateBrace !immediate
  TypeArgumentList<e>
}

TypeArgumentList[closedBy="}"]<e> {
  "{" (e | LonelyType) ("," (e | LonelyType))* ","? "}"
}

FieldName { word }

FieldExpression<pe> {
  pe
  !immediate immediateDot !dot "." !dot
  (FieldName | QuoteExpression | InterpolationExpression)
}

SubscriptExpression[closedBy="]"]<pe> {
  (pe | Number) !immediate immediateBracket "["
    // TODO re-enable
    (
      ListCompherension<s_e, s_pe> |
      // GeneratorExpression { s_e comprehensionClause<s_e, s_pe> } |
      (s_e |
       AssignmentExpression {
         s_e !assign (assignOperator | "=") s_e
       })
      ("," (s_e |
            AssignmentExpression {
              s_e !assign (assignOperator | "=") s_e
            }))*
    )?
    ","?
  "]"
}

s_e {
  blocks |
  definition |
  // CompoundExpression |
  MacroExpression<s_e, s_pe> |
  UnaryExpression<s_e> |
  BinaryExpression<s_e> |
  TernaryExpression<s_e> |
  FunctionExpression<s_e, s_pe> |
  CoefficientExpression<s_e> |
  TransposeExpression<s_e> |
  SpreadExpression<s_e> |
  s_pe |

  // Can't be called ($() is interpolation) and `:()` is quoting,
  // but can be used as lonely operators `$`
  Operator { operator<"$"> | operator<":"> } |

  // Sad sad number belongs to `e` because you can't do `10()` or `10.x`
  Number
}

s_pe {
  InterpolationExpression |
  FieldExpression<s_pe> |
  SubscriptExpression<s_pe> |
  Symbol |
  QuoteExpression |
  CallExpression<s_e, s_pe> |
  Identifier ~id |
  boolean |
  Character |
  String |
  TripleString |
  CommandString |
  PrefixedString |
  ParenthesizedExpression<s_e> |
  TupleExpression<s_e, s_pe> |
  ArrayExpression<s_e> |
  ArrayComprehensionExpression<s_e, s_pe> |
  MatrixExpression<s_e> |
  GeneratorExpression<s_e, s_pe> |
  TypedExpression<s_pe> |
  ParameterizedIdentifier<s_e, s_pe> |
  Operator ~op |
  kw<"begin"> |
  kw<"end">
}

SpreadExpression<pe> {
  (pe | Number) !dot "..."
}

TernaryExpression<e> {
  e
  !ternary ternary1 !ternary
  e
  !ternary ternary2 !ternary
  e
}

// TODO Technically should be `e`
TypePart[@name="Type"] { pe }
TypedExpression<pe> {
  (pe | Number) !typeascription (operator<"::"> | operator<"<:">) !typeascription TypePart
}

// I guess there might be more thing "coeffecientable",
// but for now this is the list
Coefficient {
  CallExpression {
    Identifier
    !call immediateParen
    !call args[@dynamicPrecedence=1] { ArgumentList<e, pe> }
  } |
  Identifier |
  FieldExpression<Identifier> |
  InterpolationExpression |
  PrefixedString |
  ParenthesizedExpression<e> |
  TupleExpression<e, pe>
}
CoefficientExpression[@dynamicPrecedence=5]<e> {
  (Number | TransposeExpression<e>)
  !coeff
  (nowhitespace | immediateParen) ~paren_after_expression Coefficient
}

CompoundExpression[closedBy="end"] {
  kw<"begin">
    expressionList<e, pe>
  end
}

CallExpression<e, pe> {
  pe
  !call BroadcastDot { immediateDot "." }?
  (nowhitespace | immediateParen) ~paren_after_expression
  !call args[@dynamicPrecedence=1] { ArgumentList<e, pe> }
  DoClause?
}

DoClause[closedBy="end"] {
  kw<"do"> 
  (
    DoClauseArguments { doArg<e, pe> ~id ("," doArg<e, pe> ~id)* } |
    terminator
  )
  ~possibly_more_expressions
  expressionList<e, pe>
  end
}

doArg<e,pe> { e ~id | LonelyType }

ListCompherension<e, pe> {
  e ~id comprehensionClause<e, pe> ~generator
}


LonelyType {
  (operator<"::"> | operator<"<:">) !typeonlyascription TypePart
}

//////////
// Quoting and interpolation
//////////

InterpolationExpression[@dynamicPrecedence=2] {
  "$" !interp (nowhitespace | immediateParen) pe
}

Symbol {
  ":" !interp (nowhitespace | immediateParen) SymbolName { word }
}

QuoteExpression[@dynamicPrecedence=2] {
  ":" !interp (nowhitespace | immediateParen) (pe | "(" operator<"="> ")" | operator<"..."> | operator<".">)
}


////////////
// Tuples, arguments and ParenthesizedExpression
////////////
ArgumentList[closedBy=")"]<e, pe> {
  "("
  (tuple_section<e,pe>? ~args_or_tuple Parameters<e,pe>*)?
  ")" ~afterclosingparen
}

ParenthesizedExpression[closedBy=")"]<e> {
  "("
  list_expression<e> ~inline-block-or-tuple (";" list_expression<e>)* ";"?
  ")"
}

TupleExpression<e, pe> {
  "("
  (tuple_section_with_comma<e,pe>? ~args_or_tuple Parameters<e,pe>*)?
  ")"
}

Parameters<e,pe> {
  ";" tuple_section<e,pe>?
}
tuple_section_with_comma<e,pe> {
    list_expression<e> "," ListCompherension<e,pe>? |
    list_expression<e> ("," list_expression<e>)+ ("," ListCompherension<e,pe>?)?
}
tuple_section<e,pe> {
    ListCompherension<e, pe> ~generator-or-tuple |
    list_expression<e>
    ~inline-block-or-tuple
    ("," list_expression<e>)*
    ("," ListCompherension<e, pe>?)?
}

list_expression<e> { e | AssignmentExpression_without_bare_tuple<e> | LonelyType }

AssignmentExpression_without_bare_tuple[@name=AssignmentExpression]<e> {
  e ~id !assign (assignOperator | "=") !assign e
}



//////////////
// Macros!
/////////////

MacroExpression<e, pe> {
  (MacroIdentifier | MacroFieldExpression<pe>)
  (
    !right0 immediateParen args[@dynamicPrecedence=1] { ArgumentList<e, pe> } DoClause? | // @use_memo([]) do; ... end
    !immediate immediateBrace !immediate TypeArgumentList<e> | // @NamedTuple{x::Int}
    MacroArgumentList<e> // Lame, normal macro call pfffft
  )?
}

MacroFieldExpression<pe> {
  pe !immediate immediateDot !dot "." !dot MacroIdentifier |
  MacroIdentifier !immediate immediateDot !dot "." !dot MacroFieldName { word }
}

MacroIdentifier {
  !regular0 "@" MacroName { word | Operator | Operator[group="operator"] { "." | "$" | ":" } }
}

MacroArgumentList<e> {
  (!regular-2 statement)+
}


// TODO Rename to and merge with `AssignmentExpression_without_bare_tuple`
function_expression_assignment[@name="AssignmentExpression"]<e> {
  e
  !assign (assignOperator | "=")
  (e | function_expression_assignment<e>)
}

FunctionExpression<e, pe> {
  (Identifier ~id | ArgumentList<e, pe>)
  !arrow "->"
  (e | function_expression_assignment<e>)
}

contains_operator { kw<"in"> | kw<"isa"> }
colon_operator { ":" }

BinaryExpression<e> {
  e !power powerOperator !power e |
  e !bitshift bitshiftOperator !bitshift e |
  e !pair pairOperator !pair e |
  e !colon colon_operator !colon e |
  e !times timesOperator !times e |
  e !plus ("$" | plusOperator) !plus e |
  e !arrow arrowOperator e |
  e !pipeback pipe_ltr e |
  e !pipe pipe_rtl e |
  e !contains (contains_operator | comparisonOperator) !contains e |
  e !bor "||" e |
  e !band "&&" e
}

UnaryExpression<e> {
  Operator { unaryOperatorExtra | plusminus } ~op !prefix e
}

Operator[group="operator"] {
  !regular0 (
    bitshiftOperator |
    unaryOperatorExtra |
    assignOperator |
    plusOperator |
    timesOperator |
    powerOperator |
    comparisonOperator |
    arrowOperator |
    contains_operator |
    pipe_ltr |
    pipe_rtl |
    colon_operator
  )
}

ArrayExpression[closedBy="]"]<e> {
  !regular0 "[" "]" |
  !regular0 "["
  !regular0 e
  ("," e)*?
  (!regular0 ",")?
  !regular0 "]"
}

MatrixExpression[closedBy="]"]<e> {
  "["
  !regular-1
  MatrixRow<e>
  (";" MatrixRow<e>)* 
  (!regular-1 ";")?
  !regular-1
  "]"
}

MatrixRow<e> {
  (!regular-1 e)+
}

ArrayComprehensionExpression[closedBy="]"]<e, pe> {
  "[" !regular0 e !regular0 comprehensionClause<e, pe> "]"
}

GeneratorExpression[closedBy=")"]<e, pe> {
  "(" ListCompherension<e, pe> ~generator-or-tuple ")" ~afterclosingparen
}

comprehensionClause<e, pe> {
  ForClause<e, pe> (ForClause<e, pe> | IfClause<e, pe>)*
}

IfClause<e, pe> {
  kw<"if"> e
}

ForClause<e, pe> {
    kw<"for"> ForBinding<e, pe> (!forbinding "," ForBinding<e, pe>)*
}

ForBinding<e, pe> {
  (Identifier ~id | TupleExpression<e, pe>) AssignOperator { kw<"in"> | operator<"="> | operator<"∈"> } e
}

ScopedIdentifier {
  "." !dot ScopedIdentifier |
  (Identifier | ScopedIdentifier)? !dot "." !dot Identifier
}

// Even though it is technically "just an unary expression",
// I'm keeping this separate because it needs immediateSingleQuote
// and because I don't feel like rewriting tests
TransposeExpression<e> {
  e !transpose immediateSingleQuote "'"
}

@skip {} {
  String {
    '"' (stringContent | StringInterpolation)* '"'
  }
  TripleString {
    '"""' (tripleStringContent | StringInterpolation)* '"""'
  }
  CommandString {
    "`" (commandStringContent | StringInterpolation)* "`"
  }

  StringWithoutInterpolation[@name="String"] {
    '"' stringContentWithoutInterpolation '"'
  }
  TripleStringWithoutInterpolation[@name="TripleString"] {
    '"""' tripleStringContentWithoutInterpolation '"""'
  }
  CommandStringWithoutInterpolation[@name="CommandString"] {
    "`" commandStringContentWithoutInterpolation "`"
  }
}

StringInterpolation {
  "$" Identifier |
  "$" immediateParen "(" e ")"
}

PrefixFieldExpression[@name=FieldEpxression] {
  PrefixFieldExpression
  // (PrefixFieldExpression | Identifier ~id)
  !immediate immediateDot !dot "." !dot
  FieldName
}
PrefixedString {
  Prefix { Identifier | PrefixFieldExpression }
  !immediate
  
  (immediateDoubleQuote StringWithoutInterpolation |
  immediateDoubleQuote TripleStringWithoutInterpolation |
  immediateBackquote CommandStringWithoutInterpolation)
}

plusOperator {
  "." !immediate nowhitespace (plusOperatorExtra | plusminus) |
  (plusOperatorExtra | plusminus)
}

operator<term> { [@name={term},group="operator"]{ term } } 

end { kw<"end"> }
kwe<term> { @extend[@name={term},group="keyword"]<Identifier, term> }
kw<term> { @specialize[@name={term},group="keyword"]<Identifier, term> }
boolean { @specialize[@name=BooleanLiteral]<Identifier, "true" | "false"> }

@external tokens layoutExtra from "./index.tokens.js" {
  immediateParen,
  immediateColon,
  immediateBrace,
  immediateBracket,
  immediateSingleQuote,
  immediateDoubleQuote,
  immediateBackquote,
  immediateDot,
  nowhitespace
}

terminator { newline | ";" }

@external tokens newline from "./index.tokens.js" { newline }

// So this is a tricky one... to have `word` for fieldnames and symbols
// but `Identifier` for Identifiers *and keywords*, I now have two tokens that are generated the same way...
// The trick is having `word` earlier in this list, so when it has to chose between `word` or `Identifier`,
// it will always take the `word` first.
@external tokens word from "./index.tokens.js" { word }
@external tokens Identifier from "./index.tokens.js" { Identifier }

@external tokens BlockComment from "./index.tokens.js" { BlockComment }
@external tokens tripleStringContent from "./index.tokens.js" { tripleStringContent }
@external tokens stringContent from "./index.tokens.js" { stringContent }
@external tokens commandStringContent from "./index.tokens.js" { commandStringContent }
@external tokens tripleStringContentWithoutInterpolation from "./index.tokens.js" { tripleStringContentWithoutInterpolation }
@external tokens stringContentWithoutInterpolation from "./index.tokens.js" { stringContentWithoutInterpolation }
@external tokens commandStringContentWithoutInterpolation from "./index.tokens.js" { commandStringContentWithoutInterpolation }

@tokens {
  whitespace {
    " " | "\t" | "\n"
  }
  Comment {
    "#" ![\n]*
  }
  Number {
    (
      "0" $[xX] $[0-9a-fA-F] $[0-9a-fA-F_]* |
      $[0-9] $[0-9_]* "."? ($[0-9] $[0-9_]*)? |
      "." $[0-9] $[0-9_]*
    )
    ($[eE] ("-" | "+")? $[0-9]+)?
  }
  powerOperator {
    "."? ("^" | "↑" | "↓" | "⇵" | "⟰" | "⟱" | "⤈" | "⤉" | "⤊" | "⤋" | "⤒" | "⤓" | "⥉" | "⥌" | "⥍" | "⥏" | "⥑" | "⥔" | "⥕" | "⥘" | "⥙" | "⥜" | "⥝" | "⥠" | "⥡" | "⥣" | "⥥" | "⥮" | "⥯" | "￪" | "￬")
  }
  timesOperator {
    "."? ("*" | "/" | "÷" | "%" | "&" | "⋅" | "∘" | "×" | "\\" | "∩" | "∧" | "⊗" | "⊘" | "⊙" | "⊚" | "⊛" | "⊠" | "⊡" | "⊓" | "∗" | "∙" | "∤" | "⅋" | "≀" | "⊼" | "⋄" | "⋆" | "⋇" | "⋉" | "⋊" | "⋋" | "⋌" | "⋏" | "⋒" | "⟑" | "⦸" | "⦼" | "⦾" | "⦿" | "⧶" | "⧷" | "⨇" | "⨰" | "⨱" | "⨲" | "⨳" | "⨴" | "⨵" | "⨶" | "⨷" | "⨸" | "⨻" | "⨼" | "⨽" | "⩀" | "⩃" | "⩄" | "⩋" | "⩍" | "⩎" | "⩑" | "⩓" | "⩕" | "⩘" | "⩚" | "⩜" | "⩞" | "⩟" | "⩠" | "⫛" | "⊍" | "▷" | "⨝" | "⟕" | "⟖" | "⟗")
  }
  plusOperatorExtra {
    "."? ("|||" | "⊕" | "⊖" | "⊞" | "⊟" | "|++|" | "∪" | "∨" | "⊔" | "±" | "∓" | "∔" | "∸" | "≂" | "≏" | "⊎" | "⊻" | "⊽" | "⋎" | "⋓" | "⧺" | "⧻" | "⨈" | "⨢" | "⨣" | "⨤" | "⨥" | "⨦" | "⨧" | "⨨" | "⨩" | "⨪" | "⨫" | "⨬" | "⨭" | "⨮" | "⨹" | "⨺" | "⩁" | "⩂" | "⩅" | "⩊" | "⩌" | "⩏" | "⩐" | "⩒" | "⩔" | "⩖" | "⩗" | "⩛" | "⩝" | "⩡" | "⩢" | "⩣")
  }
  arrowOperator {
    "."?  ("-->" | "←" | "→" | "↔" | "↚" | "↛" | "↞" | "↠" | "↢" | "↣" | "↦" | "↤" | "↮" | "⇎" | "⇍" | "⇏" | "⇐" | "⇒" | "⇔" | "⇴" | "⇶" | "⇷" | "⇸" | "⇹" | "⇺" | "⇻" | "⇼" | "⇽" | "⇾" | "⇿" | "⟵" | "⟶" | "⟷" | "⟹" | "⟺" | "⟻" | "⟼" | "⟽" | "⟾" | "⟿" | "⤀" | "⤁" | "⤂" | "⤃" | "⤄" | "⤅" | "⤆" | "⤇" | "⤌" | "⤍" | "⤎" | "⤏" | "⤐" | "⤑" | "⤔" | "⤕" | "⤖" | "⤗" | "⤘" | "⤝" | "⤞" | "⤟" | "⤠" | "⥄" | "⥅" | "⥆" | "⥇" | "⥈" | "⥊" | "⥋" | "⥎" | "⥐" | "⥒" | "⥓" | "⥖" | "⥗" | "⥚" | "⥛" | "⥞" | "⥟" | "⥢" | "⥤" | "⥦" | "⥧" | "⥨" | "⥩" | "⥪" | "⥫" | "⥬" | "⥭" | "⥰" | "⧴" | "⬱" | "⬰" | "⬲" | "⬳" | "⬴" | "⬵" | "⬶" | "⬷" | "⬸" | "⬹" | "⬺" | "⬻" | "⬼" | "⬽" | "⬾" | "⬿" | "⭀" | "⭁" | "⭂" | "⭃" | "⭄" | "⭇" | "⭈" | "⭉" | "⭊" | "⭋" | "⭌" | "￩" | "￫" | "⇜" | "⇝" | "↜" | "↝" | "↩" | "↪" | "↫" | "↬" | "↼" | "↽" | "⇀" | "⇁" | "⇄" | "⇆" | "⇇" | "⇉" | "⇋" | "⇌" | "⇚" | "⇛" | "⇠" | "⇢")
  }
  bitshiftOperator {
    "."? (">>" | "<<" | ">>>")
  }
  pairOperator {
    "."? "=>"
  }
  comparisonOperator {
    "."?  ("<:" | ">" | "<" | ">=" | "≥" | "<=" | "≤" | "==" | "===" | "≡" | "!=" | "≠" | "!==" | "≢" | "∈" | "∉" | "∋" | "∌" | "⊆" | "⊈" | "⊂" | "⊄" | "⊊" | "∝" | "∊" | "∍" | "∥" | "∦" | "∷" | "∺" | "∻" | "∽" | "∾" | "≁" | "≃" | "≂" | "≄" | "≅" | "≆" | "≇" | "≈" | "≉" | "≊" | "≋" | "≌" | "≍" | "≎" | "≐" | "≑" | "≒" | "≓" | "≖" | "≗" | "≘" | "≙" | "≚" | "≛" | "≜" | "≝" | "≞" | "≟" | "≣" | "≦" | "≧" | "≨" | "≩" | "≪" | "≫" | "≬" | "≭" | "≮" | "≯" | "≰" | "≱" | "≲" | "≳" | "≴" | "≵" | "≶" | "≷" | "≸" | "≹" | "≺" | "≻" | "≼" | "≽" | "≾" | "≿" | "⊀" | "⊁" | "⊃" | "⊅" | "⊇" | "⊉" | "⊋" | "⊏" | "⊐" | "⊑" | "⊒" | "⊜" | "⊩" | "⊬" | "⊮" | "⊰" | "⊱" | "⊲" | "⊳" | "⊴" | "⊵" | "⊶" | "⊷" | "⋍" | "⋐" | "⋑" | "⋕" | "⋖" | "⋗" | "⋘" | "⋙" | "⋚" | "⋛" | "⋜" | "⋝" | "⋞" | "⋟" | "⋠" | "⋡" | "⋢" | "⋣" | "⋤" | "⋥" | "⋦" | "⋧" | "⋨" | "⋩" | "⋪" | "⋫" | "⋬" | "⋭" | "⋲" | "⋳" | "⋴" | "⋵" | "⋶" | "⋷" | "⋸" | "⋹" | "⋺" | "⋻" | "⋼" | "⋽" | "⋾" | "⋿" | "⟈" | "⟉" | "⟒" | "⦷" | "⧀" | "⧁" | "⧡" | "⧣" | "⧤" | "⧥" | "⩦" | "⩧" | "⩪" | "⩫" | "⩬" | "⩭" | "⩮" | "⩯" | "⩰" | "⩱" | "⩲" | "⩳" | "⩵" | "⩶" | "⩷" | "⩸" | "⩹" | "⩺" | "⩻" | "⩼" | "⩽" | "⩾" | "⩿" | "⪀" | "⪁" | "⪂" | "⪃" | "⪄" | "⪅" | "⪆" | "⪇" | "⪈" | "⪉" | "⪊" | "⪋" | "⪌" | "⪍" | "⪎" | "⪏" | "⪐" | "⪑" | "⪒" | "⪓" | "⪔" | "⪕" | "⪖" | "⪗" | "⪘" | "⪙" | "⪚" | "⪛" | "⪜" | "⪝" | "⪞" | "⪟" | "⪠" | "⪡" | "⪢" | "⪣" | "⪤" | "⪥" | "⪦" | "⪧" | "⪨" | "⪩" | "⪪" | "⪫" | "⪬" | "⪭" | "⪮" | "⪯" | "⪰" | "⪱" | "⪲" | "⪳" | "⪴" | "⪵" | "⪶" | "⪷" | "⪸" | "⪹" | "⪺" | "⪻" | "⪼" | "⪽" | "⪾" | "⪿" | "⫀" | "⫁" | "⫂" | "⫃" | "⫄" | "⫅" | "⫆" | "⫇" | "⫈" | "⫉" | "⫊" | "⫋" | "⫌" | "⫍" | "⫎" | "⫏" | "⫐" | "⫑" | "⫒" | "⫓" | "⫔" | "⫕" | "⫖" | "⫗" | "⫘" | "⫙" | "⫷" | "⫸" | "⫹" | "⫺" | "⊢" | "⊣" | "⟂")
  }
  assignOperator {
    ":=" | "."? ("~" | "=" | "+=" | "-=" | "*=" | "/=" | "//=" | "^=" | "÷=" | "%=" | "<<=" | ">>=" | ">>>=" | "|=" | "&=" | "⊻=" | "≔" | "⩴" | "≕")
  }
  unaryOperatorExtra {
    "."? (">:" | "!" | "~" | "¬" | "√" | "∛" | "∜")
  }
  plusminus {
    "."? ("+" | "-" | "|")
  }
  Character {
    "'" ("\\" !['] | ![']) "'"
  }

  pipe_ltr[@name="pipe<"] { "<|" | ".<|" }
  pipe_rtl[@name="pipe>"] { "|>" | ".|>" }

  ternary1 {
    whitespace+ "?" whitespace+
  }
  ternary2 {
    whitespace+ ":" whitespace+
  }
  @precedence {
    Number,
    pipe_ltr,
    pipe_rtl,
    // <: and < will fight over two should be chosen,
    // and if possible it should always be <: (not gonna have a range expression with `<` sadly)
    "<:",
    comparisonOperator,
    "=",
    assignOperator,
    unaryOperatorExtra,
    plusOperatorExtra,
    ".",
    ternary1,
    ternary2,
    whitespace
  }
}

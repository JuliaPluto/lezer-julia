@precedence {
  interpolation
  immediate
  symbol

  imports
  renamed-import @right

  subscript
  
  dot @left
  single-is-special
  unary
  postfix
  transpose
  typeonlyascription @left
  
  type-parameters
  typeascription @left
  where @left

  prefix
  call

  // https://docs.julialang.org/en/v1/manual/mathematical-operations/#Operator-Precedence-and-Associativity
  power @left
  coefficient
  bitshift @left
  times @left
  plus @left
  colon @left
  pipe @left
  pipeback @right
  contains @left
  band @right
  bor @right

  suffix
  
  ternary @right
  pair @right
  forbinding

  something-statement
  return

  array

  baretuple
  assign @right
  arrow @right

  macro-argument
  macro

  array-comprehension

  matrix

  for-statement
  statement @right

  right0 @right
} 

@top SourceFile {
  expressionList
}

// EXPRESSIONS

expression {  
  blocky_things |
  definition |
  MacroExpression | 
  FunctionExpression |
  // TODO Imports is slow!
  import_expressions |
  CallExpression |
  
  Identifier |
  boolean |
  Character |
  Number |
  Symbol |
  String |
  TripleString |
  CommandString |

  CoefficientExpression |
  UnaryExpression |
  BinaryExpression |
  TernaryExpression |
  
  SpreadExpression |
  Where |
  LonelyType |
  Operator |
  BeginIndex |
  EndIndex |

  InterpolationExpression |
  FieldExpression |
  TransposeExpression |
  QuoteExpression |
  PrefixedString |

  SubscriptExpression |
  TypedMatrixExpression |
  TypedArrayComprehensionExpression |
  
  // NOTE TupleExpression actually makes lezer generate FASTER?
  TupleExpression |
  GeneratorExpression |
  
  square_bracket_stuff |
  // NOTE Discontinued vector might/is still used by some macros
  // .... but it also adds a couple of seconds to the build...
  discontinued_vector_syntax |
  
  TypedExpression |
  ParameterizedIdentifier | 
  
  ParenthesizedExpression
}


@skip { whitespace | Comment | BlockComment }

// TOP LEVEL

expressionList {
  terminator*
  (
    statement
    (
      terminator+
      (!statement statement)
    )*
    terminator*
  )?
}

// # STATEMENTS
// AssignmentStatement and BareTuple are the only
// nodes that can only exist at the top level of blocks:
// Inside anything the BareTuple can't exist because it becomes
// a normal tuple, and assignment also can't have BareTuple inside
// so it become a AssignmentExpression instead.
statement {
  (expression | AssignmentStatement | BareTuple)
}
BareTuple {
  expression (!baretuple "," expression)+ 
}
// Wonderful how making this a whole separate thing works, but nesting it
// inside AssignmentStatement as `BareTuple ","?` does not 🤷‍♀️
BareTuple_with_comma[@name="BareTuple"] {
  expression (!baretuple "," expression)* ","
}
AssignmentStatement[@name="AssignmentExpression"] {  
  // So I finally think I understand what `!assign` here does:
  // Lezer is not sure if, before reduce-ing `Assignee`, it should parse
  // `@m x = 10` as `(@m x) = 10` or as `@m (x = 10)`.
  // By telling it just before the reduce "Hey, if you got here, take this
  // instead of something with a lower precedence" (e.g. a macro call),
  // we make sure lezer parses this correctly
  // Assignee {
    (expression | BareTuple | BareTuple_with_comma)
    !assign
  // }
  (assignOperator | "=")
  statement
}

AssignmentExpression {
  // Using `Assignee` here makes stuff like `c -> x = true` parse as
  // `(c -> x) = true` rather than `c -> (x = true)` 😒
  expression
  !assign
  (assignOperator | "=")
  (expression | AssignmentExpression)
}

// BLOCKY THINGS

blocky_things {
  IfStatement |
  // IfStatement_Pro |
  TryCatchFinally |
  ForStatement |
  WhileStatement |
  LetStatement |
  ConstStatement |
  GlobalStatement |
  LocalStatement |
  QuoteStatement |
  BreakStatement |
  ContinueStatement |
  ReturnStatement |
  CompoundExpression
}

// IfStatement but with block matching working...
// Also creates a less readable tree, so
// TODO Look into how closedBy and openedBy is
// .... interpreted by the codemirror extension.
IfStatement_Pro {
  blockopen<"if", "else elseif end"> 
  IfClause { expression }
    expressionList
  (
    // TODO Should have openedBy="if elseif" too?
    blockcontinue<"elseif", "else elseif end">
    ElseIfClause { expression }
    expressionList
  )*
  (
    // TODO Should have openedBy "if elseif"?
    blockcontinue<"else", "end">
    ElseClause { expressionList }
  )?
  end
}

IfStatement {
  IfClause { blockopen<"if", "end"> expression }
    expressionList
  ElseifClause*
  ElseClause?
  end
}
ElseifClause {
  IfClause { kw<"elseif"> expression }
  expressionList
}
ElseClause {
  kw<"else">
  expressionList
}

TryCatchFinally[@name="TryStatement"] {
  blockopen<"try", "catch finally end">
  expressionList
  Catch?
  Finally?
  end
}
Catch[@name="CatchClause"] {
  blockcontinue<"catch", "finally end">
  (CatchBinding { Identifier } | terminator)
  expressionList
}
Finally[@name="FinallyClause"] {
  blockcontinue<"finally", "end">
  expressionList
}

ForStatement {
  !for-statement
  blockopen<"for", "end">
  ForBinding
  ("," ForBinding)*
  expressionList
  end
}

WhileStatement {
  blockopen<"while", "end"> WhileBinding { expression }
    expressionList
  end
}

BreakStatement {
  kw<"break">
}

ContinueStatement {
  kw<"continue">
}

ReturnStatement {
  kw<"return"> (!return statement)?
}

LetStatement {
  blockopen<"let", "end">
  LetBinding {
    (expression | AssignmentExpression)
    ("," (expression | AssignmentExpression))*
  }?
  terminator
  expressionList
  end
}

ConstStatement {
  kw<"const"> !something-statement AssignmentStatement
}

GlobalStatement {
  kw<"global"> !something-statement statement
}

LocalStatement {
  kw<"local"> !something-statement statement
}

QuoteStatement {
  blockopen<"quote", "end">
  expressionList
  end
}

/////////////////
// IMPORT STUFF
/////////////////

import_expressions {
  ImportStatement |
  ExportStatement
}

ImportStatement {
  (kw<"using"> | kw<"import">)
  (imports | SelectedImport)
}
ExportStatement {
  kw<"export"> import_identifier (!right0 "," import_identifier)*
}

dot { "." | immediate_dot }

import_identifier {
  MacroIdentifier |
  Operator |
  Identifier { word } |
  InterpolationExpression
}
import_path {
  import_identifier |
  ImportFieldExpression { import_path !macro dot import_identifier } |
  RelativeImport { dot import_path }
}
import {
  import_path |
  RenamedImport { import_path kw<"as"> import_identifier }
}
imports {
  import (!imports "," import)*
}
SelectedImport {
  import_path !renamed-import immediate_colon Imports { imports }
}

// DEFINITIONS

definition {
  PrimitiveDefinition |
  AbstractDefinition |
  StructDefinition |
  MutableStructDefinition |
  ModuleDefinition |
  BareModuleDefinition |
  MacroDefinition |
  FunctionDefinition
}
Definition { expression }
FunctionDefinition {
  blockopen<"function", "end"> Definition expressionList end
}
MacroDefinition {
  blockopen<"macro", "end"> Definition expressionList end
}
PrimitiveDefinition {
   "primitive type" Definition Number end
}
AbstractDefinition {
  "abstract type" Definition end
}
StructDefinition {
  blockopen<"struct", "end"> Definition expressionList end
}
MutableStructDefinition {
  "mutable struct" Definition expressionList end
}
ModuleDefinition {
  blockopen<"module", "end"> Definition expressionList end
}
BareModuleDefinition {
  blockopen<"baremodule", "end"> Definition expressionList end
}

ParameterizedIdentifier {
  expression
  !type-parameters
  TypeArgumentList
}
TypeArgumentList {
  immediate_brace inner_tuple "}"
}

FieldName { word }

FieldExpression {
  expression
  !immediate
  immediate_dot
  (FieldName | Symbol | QuoteExpression | InterpolationExpression)
}

begindex_start[@name="[",begindexing="["] { 
  immediate_bracket
}
begindex_end[@name="]",begindexing="]"] { 
  "]"
}

SubscriptExpression {
  expression
  !subscript
  begindex_start // [
  array_inner
  begindex_end // ]
}
TypedArrayComprehensionExpression {
  expression
  !subscript
  ArrayComprehensionExpression {
    begindex_start // [
    list_comprehension
    begindex_end // ]
  }
}
TypedMatrixExpression {
  expression
  !subscript
  MatrixExpression {
    begindex_start // [
    matrix_inner
    begindex_end // ]
  }
}

  // ArrayExpression { "[" array_inner? "]" } |
  // ArrayComprehensionExpression { "[" list_comprehension "]" } |
  // MatrixExpression { "[" matrix_inner "]" } |
  // // This is SO STUPID but because I love being extremely complete...
  // // Julia allows `[;;;]` but only if there is nothing between the semicolons,
  // // no expressions, no commas, no spaces, NO NOTHING
  // MatrixExpressionWithOnlySemicolons { "[" semicolons_without_spaces "]" }


SpreadExpression {
  expression !dot "..."
}

TernaryExpression {
  expression
  !ternary ternary1 !ternary
  expression
  !ternary ternary2 !ternary
  expression
}

TypedExpression {
  // Value { expression !typeascription }
  expression
  !typeascription
  (operator<"::"> | operator<"<:">)
  Type { !typeascription expression }
}

Where {
  expression
  !where
  kw<"where">
  Type { !where expression }
}

CompoundExpression {
  begin
    expressionList
  end
}

// TODO Has more edge cases:
// .... but `a'(a)` being `(a')(a)`
// .... or `(10)x` still being `10 * x`
// .... or `(x)x` being `x * x`
// .... but `(:d)x` being a syntax error?
// .... And a lot more most likely
CoefficientExpression {
  (Number | TransposeExpression)
  !coefficient
  Coefficient {
    // Need to investigate what `!coefficient` here does
    !coefficient nowhitespace expression |
    TupleInsideCoefficient[@name="TupleExpression"] {
      immediate_paren inner_tuple ")"
    } |
    ParenthesizedInsideCoefficient[@name="ParenthesizedExpression"] {
      immediate_paren inner_paren ")"
    }
  }
}

// @dynamicPrecedence is necessary to nudge `x()` to `CallExpression`
// instead of `Indentifier TupleExpression`
CallExpression[@dynamicPrecedence=1] {
  expression
  !call
  Dot[@name="BroadcastDot"] { immediate_dot }?
  ArgumentList
}

DoClause {
  blockopen<"do", "end"> 
  (
    DoClauseArguments { expression ("," expression)* } |
    terminator
  )
  expressionList
  end
}

list_comprehension {
  expression
  !forbinding
  ForClause {
    kw<"for"> ForBinding (!forbinding "," ForBinding)*
    // TODO Rename to `Filter`? :D
    Filter[@name="IfClause"] { kw<"if"> expression }*
  }+
}
ForBinding {
  expression
  AssignOperator { !immediate kw<"in"> | operator<"="> | operator<"∈"> }
  expression
}


LonelyType {
  (operator<"::"> | operator<"<:">)
  Type { !typeonlyascription expression }
}

//////////
// Quoting and interpolation
//////////
InterpolationExpression[@name="Interpolation", @dynamicPrecedence=10] {
  interpolationStart inner_paren interpolationEnd |
  interpolation_start !interpolation symbol_name |
  TupleExpression[@dynamicPrecedence=-1] {
    interpolationStart inner_tuple interpolationEnd
  }

}

Symbol {
  symbol_start !symbol symbol_name
}
symbol_name {
  Identifier { word } |
  Number |
  String |
  Operator |
  // So assign operators are special because you can't use them as
  // normal identifiers e.g. `+` is valid code, `+=` isn't, while `:+=` is!
  AssignOperatorAsSymbols[@name=Operator] { assignOperator }
}

QuoteExpression[@name=Quote,@dynamicPrecedence=10] {
  quoteStart inner_paren quoteEnd |
  // Prefer the inner_paren way
  TupleExpression[@dynamicPrecedence=-1] {
    quoteStart inner_tuple quoteEnd
  } |
  quoteStart AssignOperatorInSymbols[@name=Operator] { assignOperator | "=" } quoteEnd
}


////////////
// Tuples, arguments and ParenthesizedExpression
////////////
tuple_section {
  ListCompherension { list_comprehension } |
  (expression | AssignmentExpression)
  ~tuple-vs-parens
  (
    ("," (expression | AssignmentExpression))*
    ("," ListCompherension { list_comprehension }?)?
  )?
}
inner_tuple {
  tuple_section?
  // Calling this `Parameters` now for backwards compatibility...
  // but I feel like all inner_tuples in a TupleExpression should
  // be equal and just "inner" or something
  ((";")+ Parameters { tuple_section })*
  (";")*
}

TupleExpression {
  "(" inner_tuple ")"
}

ArgumentList {
  immediate_paren inner_tuple ")" 
  DoClause?
}

// When a tuple has one element `(a)`
// or only semicolon delimited values `(a;b;c)`
// or even only semicolons with single dangling commas `(a,;b,;c,)`
// it is not treated as a tuple, but as an inline block.
// Thanks to `~tuple-vs-parens` lezer will try both and resort to inline block if it can.
// (TODO I don't like this exception!!)
inner_paren {
  (expression | AssignmentExpression)
  ~tuple-vs-parens
  (";"+ (expression | AssignmentExpression) ","?)*
  ";"*
}
ParenthesizedExpression[@dynamicPrecedence=1] {
  "(" inner_paren ")"
}
GeneratorExpression {
  "(" list_comprehension !single-is-special ")"
}

//////////////
// Macros!
/////////////
MacroExpression[@dynamicPrecedence=10] {
  (MacroIdentifier | MacroFieldExpression)
  (    
    // @use_memo([]) do; ... end
    !immediate ArgumentList | 
    // @NamedTuple{x::Int}
    !immediate TypeArgumentList |
    // Lame, normal macro call pfffft
    MacroArgumentList { (!macro-argument statement)+ }
  )?
}

MacroFieldExpression {
  expression !immediate immediate_dot MacroIdentifier  |
  MacroIdentifier !immediate immediate_dot Identifier { word }
}

MacroIdentifier {
  "@" MacroName { 
    word |
    Operator |
    // These two aren't allowed as normal operators,
    // but are allowed as macro names 🤷‍♀️
    // TODO ".." should be here too, but conflicts with `import ..X`
    Operator[group="operator"] { "." }
  }
}

FunctionExpression {
  ArgumentList { !arrow expression !arrow }
  !arrow
  "->"
  !arrow
  (expression | AssignmentExpression)
}

contains_operator { kw<"in"> | kw<"isa"> }
// Needs `ternary2` so it can also match ` : `
// (Else just `a : b` freaks out)
colon_operator { ":" | immediate_colon | symbol_start | ternary2 }

// So turns out that if I remove all these and use
// `BinaryExpression { expression !plus "$" expression }`
// only, it about halves the time to generate...
// Just the fact there is so many tokens might overwhelm lezer..
// Maybe switch to ExternalTokenizer here too?
BinaryExpression {
  expression !power powerOperator expression |
  expression !bitshift bitshiftOperator expression |
  expression !pair pairOperator expression |
  // TODO Ideally we have ".." here too, but it causes too much
  // .... headaches to combine it with imports >_>
  // expression !colon (colon_operator | "..") expression |
  expression !colon colon_operator expression |
  expression !times timesOperator expression |
  expression !plus (plusOperator | "$") expression |
  expression !arrow arrowOperator expression |
  expression !pipeback pipe_ltr expression |
  expression !pipe pipe_rtl expression |
  expression !contains (contains_operator | comparisonOperator) expression |
  expression !bor "||" expression |
  expression !band "&&" expression
}

UnaryExpression {
  (unaryOperatorExtra | plusminus)
  !unary
  expression
}

Operator[group="operator"] {
  bitshiftOperator |
  unaryOperatorExtra |
  plusOperator |
  timesOperator |
  powerOperator |
  comparisonOperator |
  arrowOperator |
  contains_operator |
  pipe_ltr |
  pipe_rtl |
  interpolation_start |
  colon_operator
}

//////////////
// Everything inside square brackets (`[` and `]`)
/////////////
square_bracket_stuff {
  ArrayExpression { "[" array_inner? "]" } |
  ArrayComprehensionExpression { "[" list_comprehension "]" } |
  MatrixExpression { "[" matrix_inner "]" } |
  // This is SO STUPID but because I love being extremely complete...
  // Julia allows `[;;;]` but only if there is nothing between the semicolons,
  // no expressions, no commas, no spaces, NO NOTHING
  MatrixExpressionWithOnlySemicolons { "[" semicolons_without_spaces "]" }
}

matrix_inner {
  MatrixRow
  (terminator+ MatrixRow)* 
  terminator*
}
MatrixRow { (!matrix statement)+ }
array_inner {
  expression !array ("," !array expression)* (",")?
}

//////////////
// Everything inside braces (`{` and `}`)
// Which is the same as `[` and `]`
/////////////
discontinued_vector_syntax {
  OldVectorExpression { "{" array_inner? "}" } |
  OldVectorComprehensionExpression { "{" list_comprehension "}" } |
  OldMatrixExpression { "{" matrix_inner "}" } |
  OldMatrixExpressionWithOnlySemicolons { "{" semicolons_without_spaces "}" }
}



// Even though it is technically "just an unary expression",
// I'm keeping this separate because it needs immediate_single_quote
// and because I don't feel like rewriting tests
TransposeExpression {
  expression !transpose immediate_single_quote
}

@skip {} {
  String {
    '"' (stringContent | Interpolation)* '"'
  }
  TripleString {
    '"""' (tripleStringContent | Interpolation)* '"""'
  }
  CommandString {
    "`" (commandStringContent | Interpolation)* "`"
  }

  StringWithoutInterpolation[@name=] {
    stringContentWithoutInterpolation '"'
  }
  TripleStringWithoutInterpolation[@name=] {
    tripleStringContentWithoutInterpolation '"""'
  }
  CommandStringWithoutInterpolation[@name=] {
    commandStringContentWithoutInterpolation "`"
  }
}

Interpolation {
  "$" Identifier { word } |
  interpolationStart expression interpolationEnd
}

// Removed PrefixFieldExpression because it was grabbing things away from normal FieldExpressions
// PrefixFieldExpression[@name=FieldExpressionFake] {
//   (Identifier | PrefixFieldExpression)
//   !right-2 immediateDot !dot "." !dot
//   FieldName
// }
PrefixedString {
  Prefix { expression !prefix }
  (
    String { immediate_quote StringWithoutInterpolation } |
    TripleString { immediate_triple_quote TripleStringWithoutInterpolation } |
    CommandString { immediate_back_quote CommandStringWithoutInterpolation }
  )
  Suffix { nowhitespace word }?
}

operator<term> { [@name={term},group="operator"]{ term } } 
kw<term> { @specialize[@name={term},group="keyword"]<Identifier, term> }

blockopen<term, cc> {
  @specialize[
    @name={term},
    closedBy={cc},
    group="controlKeyword",
    begindexing="begin"
  ]<Identifier, term>
}
blockcontinue<term, cc> {
  @specialize[
    @name={term},
    closedBy={cc},
    group="controlKeyword"
  ]<Identifier, term>
}
boolean { @specialize[@name=BooleanLiteral]<Identifier, "true" | "false"> }

@context trackIsIndexing from "./begindexing.tokens.js"
@external prop begindexing from "./begindexing.tokens.js"
@external specialize {Identifier} begin_end_but_cool from "./begindexing.tokens.js" {
  begin[
    @name="begin",
    group="keyword",
    closedBy="end",
    begindexing="begin"
  ]
  BeginIndex
  end[
    @name="end",
    group="keyword",
    openedBy="quote begin if else elseif let try catch finally for while do function struct macro module baremodule struct mutable_struct abstract_type primitive_type",
    begindexing="end"
  ]
  EndIndex
}

// This needs to be above the other immediate_x tokens,
// specifically `immediate_paren`
@external tokens nowhitespace from "./index.tokens.js" {
  // ONLY USE FOR COEFFICIENT OR SUFFIX!!!
  // This is a very isolated case, just after numbers or tranpose, which is okay for now.
  // Ideally, think of a way to make it without nowhitespace
  nowhitespace
}
@external tokens layoutExtra from "./index.tokens.js" {
  immediate_dot[@name="."]
  
  immediate_brace[@name="{"]
  immediate_paren[@name="("]
  immediate_bracket[@name="["]
  immediate_colon[@name=":"]
  
  immediate_quote[@name="\""]
  immediate_triple_quote[@name="\"\"\""]
  immediate_back_quote[@name="`"]
  immediate_single_quote[@name="'"]

  interpolation_start[@name="$"]
  symbol_start[@name=":"]
}

terminator[@export="terminator"] { newline | semicolons_without_spaces }

@external tokens newline from "./index.tokens.js" { newline }

@external tokens BlockComment from "./index.tokens.js" { BlockComment }

@external tokens tripleStringContent from "./index.tokens.js" { tripleStringContent }
@external tokens stringContent from "./index.tokens.js" { stringContent }
@external tokens commandStringContent from "./index.tokens.js" { commandStringContent }
@external tokens tripleStringContentWithoutInterpolation from "./index.tokens.js" { tripleStringContentWithoutInterpolation }
@external tokens stringContentWithoutInterpolation from "./index.tokens.js" { stringContentWithoutInterpolation }
@external tokens commandStringContentWithoutInterpolation from "./index.tokens.js" { commandStringContentWithoutInterpolation }

plusOperator {
  plusOperatorExtra | plusminus
}

@tokens {
  // Can implement strings in pure-lezer too?
  // Still have this commented out because feels odd that it works...
  // Also fixed the ExternalTokenizer so no need to fix this yet.
  // @precedence {
  //   "$"
  //   "\"\"\""
  //   stringContent
  //   tripleStringContent
  // }
  // stringContent {
  //   (![\\"$] | "\\" _ | "$" @whitespace)+
  // }
  // tripleStringContent {
  //   (![\\"$] | "\\" _ | "$" @whitespace | "\"" ![\\"$] | "\"" "\"" ![\\"$])+
  // }
  // stringContentWithoutInterpolation {
  //   (![\\"] | "\\" _)+
  // }

  whitespace {
    " " | "\t" | "\n"
  }
  Comment {
    "#" ![\n]*
  }
  Number {
    (
      "0" $[xX] $[0-9a-fA-F] $[0-9a-fA-F_]* |
      $[0-9] $[0-9_]* "."? ($[0-9] $[0-9_]*)? |
      "." $[0-9] $[0-9_]*
    )
    ($[eE] ("-" | "+")? $[0-9]+)?
  }
  powerOperator[@name="^"] {
    "."? ("^" | "↑" | "↓" | "⇵" | "⟰" | "⟱" | "⤈" | "⤉" | "⤊" | "⤋" | "⤒" | "⤓" | "⥉" | "⥌" | "⥍" | "⥏" | "⥑" | "⥔" | "⥕" | "⥘" | "⥙" | "⥜" | "⥝" | "⥠" | "⥡" | "⥣" | "⥥" | "⥮" | "⥯" | "￪" | "￬")
  }
  timesOperator[@name="*"] {
    "."? ("*" | "/" | "÷" | "%" | "&" | "⋅" | "∘" | "×" | "\\" | "∩" | "∧" | "⊗" | "⊘" | "⊙" | "⊚" | "⊛" | "⊠" | "⊡" | "⊓" | "∗" | "∙" | "∤" | "⅋" | "≀" | "⊼" | "⋄" | "⋆" | "⋇" | "⋉" | "⋊" | "⋋" | "⋌" | "⋏" | "⋒" | "⟑" | "⦸" | "⦼" | "⦾" | "⦿" | "⧶" | "⧷" | "⨇" | "⨰" | "⨱" | "⨲" | "⨳" | "⨴" | "⨵" | "⨶" | "⨷" | "⨸" | "⨻" | "⨼" | "⨽" | "⩀" | "⩃" | "⩄" | "⩋" | "⩍" | "⩎" | "⩑" | "⩓" | "⩕" | "⩘" | "⩚" | "⩜" | "⩞" | "⩟" | "⩠" | "⫛" | "⊍" | "▷" | "⨝" | "⟕" | "⟖" | "⟗")
  }
  plusOperatorExtra[@name="⊕"] {
    "."? ("|" | "⊕" | "⊖" | "⊞" | "⊟" | "|++|" | "∪" | "∨" | "⊔" | "±" | "∓" | "∔" | "∸" | "≏" | "⊎" | "⊻" | "⊽" | "⋎" | "⋓" | "⧺" | "⧻" | "⨈" | "⨢" | "⨣" | "⨤" | "⨥" | "⨦" | "⨧" | "⨨" | "⨩" | "⨪" | "⨫" | "⨬" | "⨭" | "⨮" | "⨹" | "⨺" | "⩁" | "⩂" | "⩅" | "⩊" | "⩌" | "⩏" | "⩐" | "⩒" | "⩔" | "⩖" | "⩗" | "⩛" | "⩝" | "⩡" | "⩢" | "⩣")
  }
  arrowOperator[@name="-->"] {
    "."?  ("-->" | "←" | "→" | "↔" | "↚" | "↛" | "↞" | "↠" | "↢" | "↣" | "↦" | "↤" | "↮" | "⇎" | "⇍" | "⇏" | "⇐" | "⇒" | "⇔" | "⇴" | "⇶" | "⇷" | "⇸" | "⇹" | "⇺" | "⇻" | "⇼" | "⇽" | "⇾" | "⇿" | "⟵" | "⟶" | "⟷" | "⟹" | "⟺" | "⟻" | "⟼" | "⟽" | "⟾" | "⟿" | "⤀" | "⤁" | "⤂" | "⤃" | "⤄" | "⤅" | "⤆" | "⤇" | "⤌" | "⤍" | "⤎" | "⤏" | "⤐" | "⤑" | "⤔" | "⤕" | "⤖" | "⤗" | "⤘" | "⤝" | "⤞" | "⤟" | "⤠" | "⥄" | "⥅" | "⥆" | "⥇" | "⥈" | "⥊" | "⥋" | "⥎" | "⥐" | "⥒" | "⥓" | "⥖" | "⥗" | "⥚" | "⥛" | "⥞" | "⥟" | "⥢" | "⥤" | "⥦" | "⥧" | "⥨" | "⥩" | "⥪" | "⥫" | "⥬" | "⥭" | "⥰" | "⧴" | "⬱" | "⬰" | "⬲" | "⬳" | "⬴" | "⬵" | "⬶" | "⬷" | "⬸" | "⬹" | "⬺" | "⬻" | "⬼" | "⬽" | "⬾" | "⬿" | "⭀" | "⭁" | "⭂" | "⭃" | "⭄" | "⭇" | "⭈" | "⭉" | "⭊" | "⭋" | "⭌" | "￩" | "￫" | "⇜" | "⇝" | "↜" | "↝" | "↩" | "↪" | "↫" | "↬" | "↼" | "↽" | "⇀" | "⇁" | "⇄" | "⇆" | "⇇" | "⇉" | "⇋" | "⇌" | "⇚" | "⇛" | "⇠" | "⇢")
  }
  bitshiftOperator[@name=">>"] {
    "."? (">>" | "<<" | ">>>")
  }
  pairOperator[@name="=>"] {
    "."? "=>"
  }
  comparisonOperator[@name="=="] {
    "."?  ("<:" | ">" | "<" | ">=" | "≥" | "<=" | "≤" | "==" | "===" | "≡" | "!=" | "≠" | "!==" | "≢" | "∈" | "∉" | "∋" | "∌" | "⊆" | "⊈" | "⊂" | "⊄" | "⊊" | "∝" | "∊" | "∍" | "∥" | "∦" | "∷" | "∺" | "∻" | "∽" | "∾" | "≁" | "≃" | "≂" | "≄" | "≅" | "≆" | "≇" | "≈" | "≉" | "≊" | "≋" | "≌" | "≍" | "≎" | "≐" | "≑" | "≒" | "≓" | "≖" | "≗" | "≘" | "≙" | "≚" | "≛" | "≜" | "≝" | "≞" | "≟" | "≣" | "≦" | "≧" | "≨" | "≩" | "≪" | "≫" | "≬" | "≭" | "≮" | "≯" | "≰" | "≱" | "≲" | "≳" | "≴" | "≵" | "≶" | "≷" | "≸" | "≹" | "≺" | "≻" | "≼" | "≽" | "≾" | "≿" | "⊀" | "⊁" | "⊃" | "⊅" | "⊇" | "⊉" | "⊋" | "⊏" | "⊐" | "⊑" | "⊒" | "⊜" | "⊩" | "⊬" | "⊮" | "⊰" | "⊱" | "⊲" | "⊳" | "⊴" | "⊵" | "⊶" | "⊷" | "⋍" | "⋐" | "⋑" | "⋕" | "⋖" | "⋗" | "⋘" | "⋙" | "⋚" | "⋛" | "⋜" | "⋝" | "⋞" | "⋟" | "⋠" | "⋡" | "⋢" | "⋣" | "⋤" | "⋥" | "⋦" | "⋧" | "⋨" | "⋩" | "⋪" | "⋫" | "⋬" | "⋭" | "⋲" | "⋳" | "⋴" | "⋵" | "⋶" | "⋷" | "⋸" | "⋹" | "⋺" | "⋻" | "⋼" | "⋽" | "⋾" | "⋿" | "⟈" | "⟉" | "⟒" | "⦷" | "⧀" | "⧁" | "⧡" | "⧣" | "⧤" | "⧥" | "⩦" | "⩧" | "⩪" | "⩫" | "⩬" | "⩭" | "⩮" | "⩯" | "⩰" | "⩱" | "⩲" | "⩳" | "⩵" | "⩶" | "⩷" | "⩸" | "⩹" | "⩺" | "⩻" | "⩼" | "⩽" | "⩾" | "⩿" | "⪀" | "⪁" | "⪂" | "⪃" | "⪄" | "⪅" | "⪆" | "⪇" | "⪈" | "⪉" | "⪊" | "⪋" | "⪌" | "⪍" | "⪎" | "⪏" | "⪐" | "⪑" | "⪒" | "⪓" | "⪔" | "⪕" | "⪖" | "⪗" | "⪘" | "⪙" | "⪚" | "⪛" | "⪜" | "⪝" | "⪞" | "⪟" | "⪠" | "⪡" | "⪢" | "⪣" | "⪤" | "⪥" | "⪦" | "⪧" | "⪨" | "⪩" | "⪪" | "⪫" | "⪬" | "⪭" | "⪮" | "⪯" | "⪰" | "⪱" | "⪲" | "⪳" | "⪴" | "⪵" | "⪶" | "⪷" | "⪸" | "⪹" | "⪺" | "⪻" | "⪼" | "⪽" | "⪾" | "⪿" | "⫀" | "⫁" | "⫂" | "⫃" | "⫄" | "⫅" | "⫆" | "⫇" | "⫈" | "⫉" | "⫊" | "⫋" | "⫌" | "⫍" | "⫎" | "⫏" | "⫐" | "⫑" | "⫒" | "⫓" | "⫔" | "⫕" | "⫖" | "⫗" | "⫘" | "⫙" | "⫷" | "⫸" | "⫹" | "⫺" | "⊢" | "⊣" | "⟂")
  }
  assignOperator {
    ":=" | "."? ("~" | "+=" | "-=" | "*=" | "/=" | "//=" | "|=|" | "^=" | "÷=" | "%=" | "<<=" | ">>=" | ">>>=" | "||=|" | "&=" | "⊻=" | "≔" | "⩴" | "≕")
  }
  unaryOperatorExtra[@name="!"] {
    "."? (">:" | "!" | "~" | "¬" | "√" | "∛" | "∜")
  }
  plusminus[@name="+"] {
    "."? ("+" | "-")
  }
  Character {
    "'" ("\\" !['] | ![']) "'"
  }

  pipe_ltr[@name="pipe<"] { "<|" | ".<|" }
  pipe_rtl[@name="pipe>"] { "|>" | ".|>" }

  // semicolons_without_spaces[@name="Semicolons"] { ";"+ }
  semicolons_without_spaces[@name=";"] { ";"+ }
  
  ternary1 {
    whitespace+ "?" whitespace+
  }
  ternary2 {
    whitespace+ ":" whitespace+
  }

  "(" ")" "{" "}" "[" "]"
  ";" "," "." "..." "$" "@" "\""

  "="

  "abstract type"[@name="abstract_type", group="keyword", closedBy="end", begindexing="begin"]
  "primitive type"[@name="primitive_type", group="keyword", closedBy="end", begindexing="begin"]
  "mutable struct"[@name="mutable_struct", group="keyword", closedBy="end", begindexing="begin"]

  quoteStart[@name=":(", closedBy=")"] { ":(" }
  quoteEnd[@name=")", openedBy=":("] { ")" }

  interpolationStart[@name="$(", closedBy=")"] { "$(" }
  interpolationEnd[@name=")", openedBy="$("] { ")" }
  
  @precedence {
    "∈"
    comparisonOperator // "<" and "!="
  }

  @precedence {
    ternary1
    ternary2
    whitespace
  }
  
  @precedence {
    Number,
    pipe_ltr,
    pipe_rtl,
    // <: and < will fight over who should be chosen,
    // and if possible it should always be <: (not gonna have a range expression with `<` sadly)
    "<:",
    unaryOperatorExtra // "!" and "~"
    comparisonOperator // "<" and "!="
    "="
    // TODO Make "~" it's own token so it can be 
    assignOperator // "~"
    plusOperatorExtra
    "."
    ternary1
    ternary2
    whitespace
  }
}

// So this is a tricky one... to have `word` for fieldnames and symbols
// but `Identifier` for Identifiers *and keywords*, I now have two tokens that are generated the same way...
// The trick is having `word` earlier in this list, so when it has to chose between `word` or `Identifier`,
// it will always take the `word` first.
@external tokens word from "./index.tokens.js" { word }
@external tokens Identifier from "./index.tokens.js" { Identifier }


@external propSource juliaHighlighting from "./highlight.js"

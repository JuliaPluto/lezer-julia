@precedence {
  immediate
  dot @left
  single-is-special
  prefix
  postfix
  interp @left
  transpose
  typeonlyascription @left
  typeascription @left
  call
  
  coeff
  power @left
  bitshift @left
  times @left
  plus @left
  colon @left
  pipe @left
  pipeback @right
  contains @left
  band @right
  bor @right
  
  ternary @right
  pair @right
  forbinding
  where @left
  
  baretuple
  assign @right
  arrow @right

  array
  array-comprehension

  // This makes it so `[a $b]` is parsed correctly,
  // but it makes `[a $ b]` not work, sadly.
  // But I care more about the former ü§∑‚Äç‚ôÄÔ∏è
  matrix
  plus_but_sometimes_interpolation @right

  for-statement
  
  regular1
  right0 @right
  regular0
  regular-1
  right-2 @right
  regular-2
} 

@top SourceFile {
  expressionList | ""
}

// EXPRESSIONS

e {
  blocky_things |
  definition |
  MacroExpression |
  UnaryExpression<e> |
  BinaryExpression<e> |
  TernaryExpression<e> |
  FunctionExpression<e, pe> |
  CoefficientExpression<e> |
  SpreadExpression<e> |
  LonelyType |
  Where |
  pe
}

pe {
  Identifier |
  boolean |
  Character |
  Number |
  String |
  Symbol |
  Operator ~op |
  BeginIndex |
  EndIndex |

  InterpolationExpression |
  FieldExpression<pe> |
  TransposeExpression<e> |
  // Quick fix to trick lezer into choosing PrefixFieldExpression
  // instead of resorting to PrefixedString
  PrefixFieldExpression |
  SubscriptExpression<pe> |
  QuoteExpression |
  CallExpression<e, pe> |
  TripleString |
  CommandString |
  PrefixedString |
  ParenthesizedExpression |
  TupleExpression |
  ArrayExpression<e> |
  // TODO Discontinued vector might/is still used by some macros
  // .... but it also adds a couple of seconds to the build...
  // DiscontinuedVector |
  ArrayComprehensionExpression<e, pe> |
  MatrixExpression<e> |
  MatrixExpressionWithOnlySemicolons |
  GeneratorExpression |
  TypedExpression<pe> |
  ParameterizedIdentifier<e, pe>
}


@skip { whitespace | Comment | BlockComment }

// TOP LEVEL

expressionList {
  !right0
  terminator*
  !right0
  statement?
  (
    !right0 terminator+
    (!right0 statement)
  )*
  terminator* !right0
}

// AssignmentStatement and BareTuple are the only
// nodes that can only exist at the top level of blocks:
// Inside anything the BareTuple can't exist because it becomes
// a normal tuple, and assignment also can't have BareTuple inside
// so it become a AssignmentExpression instead.
statement {
  e | AssignmentStatement | BareTuple
}
BareTuple {
  e (!baretuple "," e)+
}
AssignmentStatement[@name="AssignmentExpression"] {
  // NOTE I'm afraid this `!assign` will skew some matches
  // .... to AssignmentStatement when they can have better matches
  // .... ^^ Exactly what happened
  // Assignee { !assign e | !assign BareTuple }
  // TODO Need to get `a, = tuple` working. Curiously, this is the only
  // .... place that a BareTuple can have a trailing comma
  // .... (`tuple = 10,` is not allowed?!)
  (e | BareTuple)
  !assign (assignOperator | "=")
  statement
}

AssignmentExpression {
  // Using `Assignee` here makes stuff like `c -> x = true` parse as
  // `(c -> x) = true` rather than `c -> (x = true)` üòí
  // Assignee { e }
  e
  !assign
  (assignOperator | "=")
  (e | AssignmentExpression)
}

// STATEMENTS

blocky_things {
  IfStatement |
  Try |
  ForStatement |
  WhileStatement |
  LetStatement |
  ConstStatement |
  GlobalStatement |
  LocalStatement |
  QuoteStatement |
  BreakStatement |
  ContinueStatement |
  ReturnStatement |
  ImportStatement |
  ExportStatement |
  CompoundExpression
}

// IfStatement but with block matching working...
// Also creates a less readable tree, so
// TODO Look into how closedBy and openedBy is
// .... interpreted by the codemirror extension.
IfStatement_Pro {
  blockkw<"if", "else elseif end"> 
  IfClause { e }
    expressionList
  (
    // TODO Should have openedBy="if elseif" too?
    blockkw<"elseif", "else elseif end">
    ElseIfClause { e }
    expressionList
  )*
  (
    // TODO Should have openedBy "if elseif"?
    blockkw<"else", "end">
    ElseClause { expressionList }
  )?
  end
}

IfStatement {
  IfClause { kw<"if"> e }
    expressionList
  ElseifClause*
  ElseClause?
  end
}
ElseifClause {
  IfClause { kw<"elseif"> e }
  expressionList
}
ElseClause {
  kw<"else">
  expressionList
}

Try[@name="TryStatement"] {
  blockkw<"try", "catch finally end">
  expressionList
  Catch?
  Finally?
  end
}

Catch[@name="CatchClause"] {
  blockkw<"catch", "finally end">
  (CatchBinding { Identifier } | terminator)
  // !regular1
  expressionList
}

Finally[@name="FinallyClause"] {
  blockkw<"finally", "end">
  expressionList
}

// TODO Should the `in`s be closedBy/openedBy too?
ForStatement {
  !for-statement
  blockkw<"for", "end">
  ForBinding<e, pe>
  ("," ForBinding<e, pe>)*
  expressionList
  end
}

WhileStatement {
  blockkw<"while", "end"> WhileBinding { e }
    expressionList
  end
}

BreakStatement {
  kw<"break">
}

ContinueStatement {
  kw<"continue">
}

ReturnStatement {
  kw<"return"> (!right-2 statement)?
}

LetStatement {
  blockkw<"let", "end">
  LetBinding {
    (e | AssignmentExpression)
    ("," (e | AssignmentExpression))*
  }?
  terminator
  expressionList
  end
}

ConstStatement {
  kw<"const"> AssignmentStatement
}

GlobalStatement {
  kw<"global"> statement
}

LocalStatement {
  kw<"local"> statement
}

QuoteStatement {
  blockkw<"quote", "end">
  expressionList
  end
}

/////////////////
// IMPORT STUFF
/////////////////

ImportStatement {
  (kw<"using"> | kw<"import">)
  (Import | SelectedImport)
}

Import {
  (Identifier | ScopedIdentifier | RenamedIdentifier)
  (!right0 "," (Identifier | ScopedIdentifier | RenamedIdentifier))*
}

SelectedImport[@dynamicPrecedence=1] {
  (Identifier | ScopedIdentifier)
  !immediate immediateColon ":"
  list {
    (RenamedImport | Identifier | MacroIdentifier | Operator)
    (!right0 "," !right0 (RenamedImport | Identifier | MacroIdentifier | Operator))*
  }
}

RenamedIdentifier {
  (Identifier | ScopedIdentifier) kw<"as"> Identifier
}

RenamedImport {
  (Identifier | ScopedIdentifier | MacroIdentifier | Operator) kw<"as"> (Identifier | MacroIdentifier | Operator)
}

ExportStatement {
  kw<"export"> (Identifier | MacroIdentifier) (!right0 "," (Identifier | MacroIdentifier))*
}

ScopedIdentifier {
  "." !dot ScopedIdentifier |
  (Identifier | ScopedIdentifier)? !dot "." !dot Identifier
}

// DEFINITIONS

definition {
  PrimitiveDefinition |
  AbstractDefinition |
  StructDefinition |
  ModuleDefinition |
  BareModuleDefinition |
  MacroDefinition |
  FunctionDefinition
}

FunctionDefinition {
  !regular0 blockkw<"function", "end">
    // Instead of ALL THIS SHIT
    // I could also do `Definition { pe }` and it would work perfectly
    // TODO Still need to make `Where` work in `pe`...
    Definition {
      // Nudgle lezer to `CallExpression { Identifier ArgumentList }`
      // instead of `Identifier TupleExpression`
      CallExpression[@dynamicPrecedence=9] {
        pe ~function-fix
        ArgumentList
        ~function-fix
        // ReturnType { "::" pe }?
      } |
      TypedExpression[@dynamicPrecedence=10] {
        CallExpression {
          pe ~function-fix
          ArgumentList
        }
        ~function-fix
        "::"
        Type { pe }
      } |
      Identifier ~function-fix |
      ArgumentList ~function-fix
    }

    // Where { kw<"where"> TypeParameters { Identifier | TypeArgumentList } }?
    (kw<"where"> TypeParameters { Identifier | type_argument_list })?
    expressionList
  end
}
Definition { pe }
MacroDefinition {
  blockkw<"macro", "end"> Definition immediateParen ArgumentList
    expressionList
  end
}

PrimitiveDefinition {
  blockkw<"primitive", "end"> blockkw<"type", "end"> Definition Number end
}

AbstractDefinition {
  blockkw<"abstract", "end"> blockkw<"type", "end"> Definition end
}

StructDefinition {
  blockkw<"mutable", "end">? blockkw<"struct", "end"> Definition !regular0
    expressionList
  end
}

ModuleDefinition {
  blockkw<"module", "end"> Definition
    expressionList
  end
}

BareModuleDefinition {
  blockkw<"baremodule", "end"> Definition
    expressionList
  end
}

ParameterizedIdentifier<e, pe> {
  pe
  !immediate immediateBrace !immediate
  TypeArgumentList
}

type_argument_list { "{" e ("," e)* ","? "}" }
TypeArgumentList {
  type_argument_list
}

FieldName { word }

FieldExpression<pe> {
  pe
  !immediate immediateDot !dot "." !dot
  (FieldName | QuoteExpression | InterpolationExpression)
}

SubscriptExpression<pe> {
  pe !immediate immediateBracket "["
    (
      ListCompherension |
      (e | AssignmentExpression)
      ("," (e | AssignmentExpression))*
    )?
    ","?
  "]"
}

SpreadExpression<pe> {
  pe !dot "..."
}

TernaryExpression<e> {
  e
  !ternary ternary1 !ternary
  e
  !ternary ternary2 !ternary
  e
}

TypePart[@name="Type"] { pe }
TypedExpression<pe> {
  pe !typeascription
  (operator<"::"> | operator<"<:">)
  !typeascription TypePart
}

Where {
  e
  !where
  kw<"where">
  TypeParameters {
    !where e |
    type_argument_list
  }
}

CoefficientExpression[@dynamicPrecedence=5]<e> {
  (Number | TransposeExpression<e>)
  !coeff
  (nowhitespace | immediateParen) Coefficient { pe }
}

CompoundExpression {
  begin
    expressionList
  end
}

CallExpression<e, pe> {
  pe
  !call BroadcastDot { immediateDot "." }?
  (nowhitespace | immediateParen)
  !call [@dynamicPrecedence=1] { ArgumentList }
  DoClause?
}

DoClause {
  blockkw<"do", "end"> 
  (
    DoClauseArguments { e ("," e)* } |
    terminator
  )
  expressionList
  end
}

ListCompherension {
  e comprehensionClause<e, pe>
}


LonelyType {
  (operator<"::"> | operator<"<:">) !typeonlyascription TypePart
}

//////////
// Quoting and interpolation
//////////

InterpolationExpression[@dynamicPrecedence=10] {
  "$" !interp (nowhitespace | immediateParen) pe
}

Symbol[@dynamicPrecedence=10] {
  ":" !interp (nowhitespace | immediateParen)
  // So assign operators are special because you can't use them as
  // normal identifiers e.g. `+` is valid code, `+=` isn't, while `:+=` is!
  SymbolName { word | Operator { assignOperator } }
}

QuoteExpression[@dynamicPrecedence=9] {
  ":" !interp (nowhitespace | immediateParen)
  // And the most exceptional is `=`, because you can't even do `:=`,
  // you have to do `:(=)` to get an equals symbol.
  (
    pe |
    "(" ParenthesizedExpression { Operator { assignOperator | "=" } } ")"
  )
}


////////////
// Tuples, arguments and ParenthesizedExpression
////////////
inner_tuple {
  (
    ListCompherension |
    (e | AssignmentExpression)
    ~tuple-vs-parens
    (
      ("," (e | AssignmentExpression))*
      ("," ListCompherension?)?
    )?
  )
}
TupleExpression {
  "("
  (
    inner_tuple?
    // Calling this `Parameters` now for backwards compatibility...
    // but I feel like all inner_tuples in a TupleExpression should
    // be equal and just "inner" or something
    ((";")+ Parameters { inner_tuple })*
    (";")*
  )?
  ")"
}
// I just ignore `e` and `pe` here lol
ArgumentList {
  "("
  (
    inner_tuple?
    ((";")+ Parameters { inner_tuple })*
    (";")*
  )?
  ")"
}

// When a tuple has one element `(a)`
// or only semicolon delimited values `(a;b;c)`
// or even only semicolons with single dangling commas `(a,;b,;c,)`
// it is not treated as a tuple, but as an inline block.
// Thanks to `~tuple-vs-parens` lezer will try both and resort to inline block if it can.
// (TODO I don't like this exception!!)
ParenthesizedExpression[@dynamicPrecedence=1] {
  "("
  (e | AssignmentExpression)
  ~tuple-vs-parens
  (";"+ (e | AssignmentExpression) ","?)*
  ";"*
  ")"
}
GeneratorExpression {
  "(" ListCompherension !single-is-special ")"
}

// This shouldn't have tuple semantics,
// but matrix/array semantics!
DiscontinuedVector {
  "{"
  (
    inner_tuple?
    ((";")+ Parameters { inner_tuple })*
    (";")*
  )?
  "}"
}

//////////////
// Macros!
/////////////

MacroExpression {
  (MacroIdentifier | MacroFieldExpression)
  (
    immediateParen args[@dynamicPrecedence=10] { ArgumentList } DoClause? | // @use_memo([]) do; ... end
    immediateBrace TypeArgumentList | // @NamedTuple{x::Int}
    MacroArgumentList // Lame, normal macro call pfffft
  )?
}

MacroFieldExpression {
  pe !immediate immediateDot !dot "." !dot MacroIdentifier |
  MacroIdentifier !immediate immediateDot !dot "." !dot MacroFieldName { word }
}

MacroIdentifier {
  "@" MacroName { word | Operator | Operator[group="operator"] { "." } }
}

MacroArgumentList {
  (!regular-2 statement)+
}

FunctionExpression<e, pe> {
  (ArgumentList { Identifier } | ArgumentList)
  !arrow "->"
  (e | AssignmentExpression)
}

contains_operator { kw<"in"> | kw<"isa"> }
// Needs `ternary2` so it can also match ` : `
// (Else just `a : b` freaks out)
colon_operator { ":" | ternary2 }

// So turns out that if I remove all these and use
// `BinaryExpression<e> { e !plus "$" e }`
// only, it about halves the time to generate...
// Just the fact there is so many tokens might overwhelm lezer..
// Maybe switch to ExternalTokenizer here too?
BinaryExpression<e> {
  e !power powerOperator e |
  e !bitshift bitshiftOperator e |
  e !pair pairOperator e |
  e !colon colon_operator e |
  e !times timesOperator e |
  e !plus plusOperator e |
  e !plus_but_sometimes_interpolation "$" e |
  e !arrow arrowOperator e |
  e !pipeback pipe_ltr e |
  e !pipe pipe_rtl e |
  e !contains (contains_operator | comparisonOperator) e |
  e !bor "||" e |
  e !band "&&" e
}

UnaryExpression<e> {
  Operator { unaryOperatorExtra | plusminus } ~op !prefix e
}

Operator[group="operator"] {
  !regular0 (
    "$" |
    bitshiftOperator |
    unaryOperatorExtra |
    plusOperator |
    timesOperator |
    powerOperator |
    comparisonOperator |
    arrowOperator |
    contains_operator |
    pipe_ltr |
    pipe_rtl |
    colon_operator
  )
}

ArrayExpression<e> {
  "[" "]" |
  "[" e !array ("," e)* (",")? "]"
}

// I have this defined in tokens as well...
// Not sure which is better, having the semicolons as one token
// or as x semicolon tokens.
// semicolons_without_spaces[@name="Semicolons"] { ";" (nowhitespace ";")* }

MatrixExpression<e> {
  "["
  !regular-1
  MatrixRow<e>
  (semicolons_without_spaces MatrixRow<e>)* 
  semicolons_without_spaces?
  !regular-1
  "]"
}

// This is SO STUPID but because I love being extremely complete...
// Julia allows `[;;;]` but only if there is nothing between the semicolons,
// no expressions, no commas, no spaces, NO NOTHING
MatrixExpressionWithOnlySemicolons {
  "[" semicolons_without_spaces "]"
}

MatrixRow<e> {
  (!matrix e)+
}

ArrayComprehensionExpression<e, pe> {
  "[" !array-comprehension e !array-comprehension comprehensionClause<e, pe> "]"
}

comprehensionClause<e, pe> {
  ForClause<e, pe> (ForClause<e, pe> | IfClause<e, pe>)*
}

IfClause<e, pe> {
  kw<"if"> e
}

ForClause<e, pe> {
    kw<"for"> ForBinding<e, pe> (!forbinding "," ForBinding<e, pe>)*
}

ForBinding<e, pe> {
  // COULD-DO `pe` here _should_ be `e`
  pe AssignOperator { kw<"in"> | operator<"="> | operator<"‚àà"> } e
}

// Even though it is technically "just an unary expression",
// I'm keeping this separate because it needs immediateSingleQuote
// and because I don't feel like rewriting tests
TransposeExpression<e> {
  pe !transpose immediateSingleQuote "'"
}

@skip {} {
  String {
    '"' (stringContent | Interpolation)* '"'
  }
  TripleString {
    '"""' (tripleStringContent | Interpolation)* '"""'
  }
  CommandString {
    "`" (commandStringContent | Interpolation)* "`"
  }

  StringWithoutInterpolation[@name="String"] {
    '"' stringContentWithoutInterpolation '"'
  }
  TripleStringWithoutInterpolation[@name="TripleString"] {
    '"""' tripleStringContentWithoutInterpolation '"""'
  }
  CommandStringWithoutInterpolation[@name="CommandString"] {
    "`" commandStringContentWithoutInterpolation "`"
  }
}

Interpolation[@name=] {
  operator<"$"> Identifier |
  operator<"$"> immediateParen operator<"("> !regular1 e !regular1 operator<")">
}

PrefixFieldExpression[@name=FieldExpression] {
  (Identifier | PrefixFieldExpression)
  !immediate immediateDot !dot "." !dot
  FieldName
}
PrefixedString {
  Prefix { Identifier | PrefixFieldExpression }
  !immediate
  (
    immediateDoubleQuote StringWithoutInterpolation |
    immediateDoubleQuote TripleStringWithoutInterpolation |
    immediateBackquote CommandStringWithoutInterpolation
  )
}

plusOperator {
  "." !immediate nowhitespace (plusOperatorExtra | plusminus) |
  (plusOperatorExtra | plusminus)
}

operator<term> { [@name={term},group="operator"]{ term } } 
kw<term> { @specialize[@name={term},group="keyword"]<Identifier, term> }
blockkw<term, cc> { @specialize[@name={term},closedBy={cc}, group="keyword"]<Identifier, term> }
boolean { @specialize[@name=BooleanLiteral]<Identifier, "true" | "false"> }

@context trackIsIndexing from "./begindexing.tokens.js"
@external specialize {Identifier} begin_end_but_cool from "./begindexing.tokens.js" {
  begin[@name="begin", group="keyword", closedBy="end"]
  BeginIndex
  end[@name="end", group="keyword", openedBy="begin if else elseif let try catch finally for while function struct macro module baremodule struct abstract primitive type do"]
  EndIndex
}

@external tokens layoutExtra from "./index.tokens.js" {
  immediateParen,
  immediateColon,
  immediateBrace,
  immediateBracket,
  immediateSingleQuote,
  immediateDoubleQuote,
  immediateBackquote,
  immediateDot,
  nowhitespace
}

terminator[@export="terminator"] { newline | ";" }

@external tokens newline from "./index.tokens.js" { newline }

// So this is a tricky one... to have `word` for fieldnames and symbols
// but `Identifier` for Identifiers *and keywords*, I now have two tokens that are generated the same way...
// The trick is having `word` earlier in this list, so when it has to chose between `word` or `Identifier`,
// it will always take the `word` first.
@external tokens word from "./index.tokens.js" { word }
@external tokens Identifier from "./index.tokens.js" { Identifier }

@external tokens BlockComment from "./index.tokens.js" { BlockComment }

@external tokens tripleStringContent from "./index.tokens.js" { tripleStringContent }
@external tokens stringContent from "./index.tokens.js" { stringContent }
@external tokens commandStringContent from "./index.tokens.js" { commandStringContent }
@external tokens tripleStringContentWithoutInterpolation from "./index.tokens.js" { tripleStringContentWithoutInterpolation }
@external tokens stringContentWithoutInterpolation from "./index.tokens.js" { stringContentWithoutInterpolation }
@external tokens commandStringContentWithoutInterpolation from "./index.tokens.js" { commandStringContentWithoutInterpolation }

@tokens {
  "["[@export="BracketL"] 
  "]"[@export="BracketR"] 

  // Can implement strings in pure-lezer too?
  // Still have this commented out because feels odd that it works...
  // Also fixed the ExternalTokenizer so no need to fix this yet.
  // @precedence {
  //   "$"
  //   "\"\"\""
  //   stringContent
  //   tripleStringContent
  // }
  // stringContent {
  //   (![\\"$] | "\\" _ | "$" @whitespace)+
  // }
  // tripleStringContent {
  //   (![\\"$] | "\\" _ | "$" @whitespace | "\"" ![\\"$] | "\"" "\"" ![\\"$])+
  // }
  // stringContentWithoutInterpolation {
  //   (![\\"] | "\\" _)+
  // }

  whitespace {
    " " | "\t" | "\n"
  }
  Comment {
    "#" ![\n]*
  }
  Number {
    (
      "0" $[xX] $[0-9a-fA-F] $[0-9a-fA-F_]* |
      $[0-9] $[0-9_]* "."? ($[0-9] $[0-9_]*)? |
      "." $[0-9] $[0-9_]*
    )
    ($[eE] ("-" | "+")? $[0-9]+)?
  }
  powerOperator {
    "."? ("^" | "‚Üë" | "‚Üì" | "‚áµ" | "‚ü∞" | "‚ü±" | "‚§à" | "‚§â" | "‚§ä" | "‚§ã" | "‚§í" | "‚§ì" | "‚•â" | "‚•å" | "‚•ç" | "‚•è" | "‚•ë" | "‚•î" | "‚•ï" | "‚•ò" | "‚•ô" | "‚•ú" | "‚•ù" | "‚•†" | "‚•°" | "‚•£" | "‚••" | "‚•Æ" | "‚•Ø" | "Ôø™" | "Ôø¨")
  }
  timesOperator {
    "."? ("*" | "/" | "√∑" | "%" | "&" | "‚ãÖ" | "‚àò" | "√ó" | "\\" | "‚à©" | "‚àß" | "‚äó" | "‚äò" | "‚äô" | "‚äö" | "‚äõ" | "‚ä†" | "‚ä°" | "‚äì" | "‚àó" | "‚àô" | "‚à§" | "‚Öã" | "‚âÄ" | "‚äº" | "‚ãÑ" | "‚ãÜ" | "‚ãá" | "‚ãâ" | "‚ãä" | "‚ãã" | "‚ãå" | "‚ãè" | "‚ãí" | "‚üë" | "‚¶∏" | "‚¶º" | "‚¶æ" | "‚¶ø" | "‚ß∂" | "‚ß∑" | "‚®á" | "‚®∞" | "‚®±" | "‚®≤" | "‚®≥" | "‚®¥" | "‚®µ" | "‚®∂" | "‚®∑" | "‚®∏" | "‚®ª" | "‚®º" | "‚®Ω" | "‚©Ä" | "‚©É" | "‚©Ñ" | "‚©ã" | "‚©ç" | "‚©é" | "‚©ë" | "‚©ì" | "‚©ï" | "‚©ò" | "‚©ö" | "‚©ú" | "‚©û" | "‚©ü" | "‚©†" | "‚´õ" | "‚äç" | "‚ñ∑" | "‚®ù" | "‚üï" | "‚üñ" | "‚üó")
  }
  plusOperatorExtra {
    "."? ("|||" | "‚äï" | "‚äñ" | "‚äû" | "‚äü" | "|++|" | "‚à™" | "‚à®" | "‚äî" | "¬±" | "‚àì" | "‚àî" | "‚à∏" | "‚âÇ" | "‚âè" | "‚äé" | "‚äª" | "‚äΩ" | "‚ãé" | "‚ãì" | "‚ß∫" | "‚ßª" | "‚®à" | "‚®¢" | "‚®£" | "‚®§" | "‚®•" | "‚®¶" | "‚®ß" | "‚®®" | "‚®©" | "‚®™" | "‚®´" | "‚®¨" | "‚®≠" | "‚®Æ" | "‚®π" | "‚®∫" | "‚©Å" | "‚©Ç" | "‚©Ö" | "‚©ä" | "‚©å" | "‚©è" | "‚©ê" | "‚©í" | "‚©î" | "‚©ñ" | "‚©ó" | "‚©õ" | "‚©ù" | "‚©°" | "‚©¢" | "‚©£")
  }
  arrowOperator {
    "."?  ("-->" | "‚Üê" | "‚Üí" | "‚Üî" | "‚Üö" | "‚Üõ" | "‚Üû" | "‚Ü†" | "‚Ü¢" | "‚Ü£" | "‚Ü¶" | "‚Ü§" | "‚ÜÆ" | "‚áé" | "‚áç" | "‚áè" | "‚áê" | "‚áí" | "‚áî" | "‚á¥" | "‚á∂" | "‚á∑" | "‚á∏" | "‚áπ" | "‚á∫" | "‚áª" | "‚áº" | "‚áΩ" | "‚áæ" | "‚áø" | "‚üµ" | "‚ü∂" | "‚ü∑" | "‚üπ" | "‚ü∫" | "‚üª" | "‚üº" | "‚üΩ" | "‚üæ" | "‚üø" | "‚§Ä" | "‚§Å" | "‚§Ç" | "‚§É" | "‚§Ñ" | "‚§Ö" | "‚§Ü" | "‚§á" | "‚§å" | "‚§ç" | "‚§é" | "‚§è" | "‚§ê" | "‚§ë" | "‚§î" | "‚§ï" | "‚§ñ" | "‚§ó" | "‚§ò" | "‚§ù" | "‚§û" | "‚§ü" | "‚§†" | "‚•Ñ" | "‚•Ö" | "‚•Ü" | "‚•á" | "‚•à" | "‚•ä" | "‚•ã" | "‚•é" | "‚•ê" | "‚•í" | "‚•ì" | "‚•ñ" | "‚•ó" | "‚•ö" | "‚•õ" | "‚•û" | "‚•ü" | "‚•¢" | "‚•§" | "‚•¶" | "‚•ß" | "‚•®" | "‚•©" | "‚•™" | "‚•´" | "‚•¨" | "‚•≠" | "‚•∞" | "‚ß¥" | "‚¨±" | "‚¨∞" | "‚¨≤" | "‚¨≥" | "‚¨¥" | "‚¨µ" | "‚¨∂" | "‚¨∑" | "‚¨∏" | "‚¨π" | "‚¨∫" | "‚¨ª" | "‚¨º" | "‚¨Ω" | "‚¨æ" | "‚¨ø" | "‚≠Ä" | "‚≠Å" | "‚≠Ç" | "‚≠É" | "‚≠Ñ" | "‚≠á" | "‚≠à" | "‚≠â" | "‚≠ä" | "‚≠ã" | "‚≠å" | "Ôø©" | "Ôø´" | "‚áú" | "‚áù" | "‚Üú" | "‚Üù" | "‚Ü©" | "‚Ü™" | "‚Ü´" | "‚Ü¨" | "‚Üº" | "‚ÜΩ" | "‚áÄ" | "‚áÅ" | "‚áÑ" | "‚áÜ" | "‚áá" | "‚áâ" | "‚áã" | "‚áå" | "‚áö" | "‚áõ" | "‚á†" | "‚á¢")
  }
  bitshiftOperator {
    "."? (">>" | "<<" | ">>>")
  }
  pairOperator {
    "."? "=>"
  }
  comparisonOperator {
    "."?  ("<:" | ">" | "<" | ">=" | "‚â•" | "<=" | "‚â§" | "==" | "===" | "‚â°" | "!=" | "‚â†" | "!==" | "‚â¢" | "‚àà" | "‚àâ" | "‚àã" | "‚àå" | "‚äÜ" | "‚äà" | "‚äÇ" | "‚äÑ" | "‚ää" | "‚àù" | "‚àä" | "‚àç" | "‚à•" | "‚à¶" | "‚à∑" | "‚à∫" | "‚àª" | "‚àΩ" | "‚àæ" | "‚âÅ" | "‚âÉ" | "‚âÇ" | "‚âÑ" | "‚âÖ" | "‚âÜ" | "‚âá" | "‚âà" | "‚ââ" | "‚âä" | "‚âã" | "‚âå" | "‚âç" | "‚âé" | "‚âê" | "‚âë" | "‚âí" | "‚âì" | "‚âñ" | "‚âó" | "‚âò" | "‚âô" | "‚âö" | "‚âõ" | "‚âú" | "‚âù" | "‚âû" | "‚âü" | "‚â£" | "‚â¶" | "‚âß" | "‚â®" | "‚â©" | "‚â™" | "‚â´" | "‚â¨" | "‚â≠" | "‚âÆ" | "‚âØ" | "‚â∞" | "‚â±" | "‚â≤" | "‚â≥" | "‚â¥" | "‚âµ" | "‚â∂" | "‚â∑" | "‚â∏" | "‚âπ" | "‚â∫" | "‚âª" | "‚âº" | "‚âΩ" | "‚âæ" | "‚âø" | "‚äÄ" | "‚äÅ" | "‚äÉ" | "‚äÖ" | "‚äá" | "‚äâ" | "‚äã" | "‚äè" | "‚äê" | "‚äë" | "‚äí" | "‚äú" | "‚ä©" | "‚ä¨" | "‚äÆ" | "‚ä∞" | "‚ä±" | "‚ä≤" | "‚ä≥" | "‚ä¥" | "‚äµ" | "‚ä∂" | "‚ä∑" | "‚ãç" | "‚ãê" | "‚ãë" | "‚ãï" | "‚ãñ" | "‚ãó" | "‚ãò" | "‚ãô" | "‚ãö" | "‚ãõ" | "‚ãú" | "‚ãù" | "‚ãû" | "‚ãü" | "‚ã†" | "‚ã°" | "‚ã¢" | "‚ã£" | "‚ã§" | "‚ã•" | "‚ã¶" | "‚ãß" | "‚ã®" | "‚ã©" | "‚ã™" | "‚ã´" | "‚ã¨" | "‚ã≠" | "‚ã≤" | "‚ã≥" | "‚ã¥" | "‚ãµ" | "‚ã∂" | "‚ã∑" | "‚ã∏" | "‚ãπ" | "‚ã∫" | "‚ãª" | "‚ãº" | "‚ãΩ" | "‚ãæ" | "‚ãø" | "‚üà" | "‚üâ" | "‚üí" | "‚¶∑" | "‚ßÄ" | "‚ßÅ" | "‚ß°" | "‚ß£" | "‚ß§" | "‚ß•" | "‚©¶" | "‚©ß" | "‚©™" | "‚©´" | "‚©¨" | "‚©≠" | "‚©Æ" | "‚©Ø" | "‚©∞" | "‚©±" | "‚©≤" | "‚©≥" | "‚©µ" | "‚©∂" | "‚©∑" | "‚©∏" | "‚©π" | "‚©∫" | "‚©ª" | "‚©º" | "‚©Ω" | "‚©æ" | "‚©ø" | "‚™Ä" | "‚™Å" | "‚™Ç" | "‚™É" | "‚™Ñ" | "‚™Ö" | "‚™Ü" | "‚™á" | "‚™à" | "‚™â" | "‚™ä" | "‚™ã" | "‚™å" | "‚™ç" | "‚™é" | "‚™è" | "‚™ê" | "‚™ë" | "‚™í" | "‚™ì" | "‚™î" | "‚™ï" | "‚™ñ" | "‚™ó" | "‚™ò" | "‚™ô" | "‚™ö" | "‚™õ" | "‚™ú" | "‚™ù" | "‚™û" | "‚™ü" | "‚™†" | "‚™°" | "‚™¢" | "‚™£" | "‚™§" | "‚™•" | "‚™¶" | "‚™ß" | "‚™®" | "‚™©" | "‚™™" | "‚™´" | "‚™¨" | "‚™≠" | "‚™Æ" | "‚™Ø" | "‚™∞" | "‚™±" | "‚™≤" | "‚™≥" | "‚™¥" | "‚™µ" | "‚™∂" | "‚™∑" | "‚™∏" | "‚™π" | "‚™∫" | "‚™ª" | "‚™º" | "‚™Ω" | "‚™æ" | "‚™ø" | "‚´Ä" | "‚´Å" | "‚´Ç" | "‚´É" | "‚´Ñ" | "‚´Ö" | "‚´Ü" | "‚´á" | "‚´à" | "‚´â" | "‚´ä" | "‚´ã" | "‚´å" | "‚´ç" | "‚´é" | "‚´è" | "‚´ê" | "‚´ë" | "‚´í" | "‚´ì" | "‚´î" | "‚´ï" | "‚´ñ" | "‚´ó" | "‚´ò" | "‚´ô" | "‚´∑" | "‚´∏" | "‚´π" | "‚´∫" | "‚ä¢" | "‚ä£" | "‚üÇ")
  }
  assignOperator {
    ":=" | "."? ("~" | "=" | "+=" | "-=" | "*=" | "/=" | "//=" | "|=|" | "^=" | "√∑=" | "%=" | "<<=" | ">>=" | ">>>=" | "||=|" | "&=" | "‚äª=" | "‚âî" | "‚©¥" | "‚âï")
  }
  unaryOperatorExtra {
    "."? (">:" | "!" | "~" | "¬¨" | "‚àö" | "‚àõ" | "‚àú")
  }
  plusminus {
    "."? ("+" | "-" | "|")
  }
  Character {
    "'" ("\\" !['] | ![']) "'"
  }

  pipe_ltr[@name="pipe<"] { "<|" | ".<|" }
  pipe_rtl[@name="pipe>"] { "|>" | ".|>" }

  // semicolons_without_spaces[@name="Semicolons"] { ";"+ }
  semicolons_without_spaces { ";"+ }
  
  ternary1 {
    whitespace+ "?" whitespace+
  }
  ternary2 {
    whitespace+ ":" whitespace+
  }
  @precedence {    
    Number,
    pipe_ltr,
    pipe_rtl,
    // <: and < will fight over two should be chosen,
    // and if possible it should always be <: (not gonna have a range expression with `<` sadly)
    "<:",
    unaryOperatorExtra
    comparisonOperator,
    "=",
    assignOperator,
    plusOperatorExtra,
    ".",
    ternary1,
    ternary2,
    whitespace
  }
}

@external propSource juliaHighlighting from "./highlight.js"

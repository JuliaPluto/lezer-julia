@precedence {
  quote @left
  dot @left
  call
  ctrans
  juxt @left

  where @left // Inner `where`
  decl @left
  power @right
  unary @right
  bitshift @left
  rational @left
  times @left
  plus @left
  colon @left
  pipe-right @left
  pipe-left @right
  comparison @left
  lazy-and @right
  lazy-or @right
  arrow @right
  ternary @right
  pair @right
  afunc @right

  vec
  tup // Comma outside parentheses (OpenTuple)
  assignment @right
  simple @right
  mat
  macro
}

@skip { _ws | LineComment | BlockComment }

@top SourceFile { block? }

block { _t? top-level (_t top-level)* _t? }

top-level { expr | Assignment | OpenTuple }

Assignment {
  (primary-expr | operation | Operator | OpenTuple)
  !assignment eq-operator
  top-level
}

OpenTuple { expr (!tup ',' expr)+ }

expr {
  ( simple-statement
  | compound-statement
  | definition
  | primary-expr
  | operation
  | Operator ~op-as-id
  | colon[@name=Operator] { ':' }
  | FloatLiteral
  | IntegerLiteral
  | JuxtapositionExpr {
      (primary-expr | FloatLiteral | IntegerLiteral)
      !juxt immediateIdentifier primary-expr
    }
  | OpenMacrocallExpr {
      MacroIdentifier
      MacroArguments { macro-arg[@dynamicPrecedence=-1] { (!macro top-level) }+ }?
    }
  )
}


// STATEMENTS

kw<term> { @extend[@name={term},group='keyword']<Identifier, term> }

end { kw<'end'> }

exportable { Identifier | MacroIdentifier | Operator }
importable {
  ( exportable
  | RelativeQualifier { '.'+ !dot Identifier }
  | ImportAlias { exportable kw<'as'> exportable }
  )
}

// Use dynamic precedence so keywords in macros don't parse as identifiers.
simple-statement[@dynamicPrecedence=1] {
  ( BreakStmt { kw<'break'> }
  | ContinueStmt { kw<'continue'> }
  | ReturnStmt { kw<'return'> !simple (expr | OpenTuple) }
  | ExportStmt { kw<'export'> !simple sep1<(!tup ','), exportable> }
  | ImportStmt { (kw<'import'> | kw<'using'>) !simple sep1<(!tup ','), importable> }
  | ConstStmt { kw<'const'> !simple Assignment }
  | GlobalStmt { kw<'global'> !simple top-level }
  | LocalStmt { kw<'local'> !simple top-level }
  )
}

ElseIfClause { kw<'elseif'> expr block? }
ElseClause { kw<'else'> block? }
CatchClause { kw<'catch'> Identifier _t block? }
FinallyClause { kw<'finally'> block? }

compound-statement[@dynamicPrecedence=1] {
  ( BeginStmt { kw<'begin'> block? end }
  | QuoteStmt { kw<'quote'> block? end }
  | WhileStmt { kw<'while'> expr block? end }
  | ForStmt { kw<'for'> sep1<',', ForBinding> ~gen-or-for block? end }
  | LetStmt { kw<'let'> sep1<',', LetBinding { Identifier !assignment '=' expr }>? _t block? end }
  | IfStmt { kw<'if'> expr block? ElseIfClause* ElseClause? end }
  | TryStmt { kw<'try'> block? (CatchClause ElseClause? FinallyClause? | FinallyClause CatchClause?) end }
  | DoStmt { (CallExpr | ClosedMacrocallExpr) kw<'do'> block? end } // TODO: do-parameters
  )
}

definition {
  ( AbstractDef { kw<'abstract'> kw<'type'> Identifier end }
  | PrimitiveDef { kw<'primitive'> kw<'type'> Identifier IntegerLiteral end }
  | StructDef { kw<'mutable'>? kw<'struct'> Identifier block? end }
  | ModuleDef { (kw<'module'> | kw<'baremodule'>) Identifier block? end }
  | FunctionDef { kw<'function'> CallExpr block? end } // TODO: function-signature
  | MacroDef { kw<'macro'> CallExpr block? end }
  )
}


// PRIMARY EXPRESSIONS

quotable {
  ( Identifier
  | CharLiteral
  | string
  | BraceExpr
  | ParenExpr
  | TupleExpr
  | array
  )
}

sep<delim, rule> { (rule (delim rule)* delim?)? }
sep1<delim, rule> { rule (delim rule)* }

BraceExpr { '{' sep<',', expr> '}' }
ParenExpr { '(' sep1<';', (expr | Assignment | Generator)> ')' }
TupleExpr { '(' (expr ',' | expr (',' expr)+ ','?)? ')' }


ForBinding { Identifier !assignment ('=' | '∈' | kw<'in'>) expr }
GenFor { kw<'for'> sep1<',', ForBinding> }
GenFilter { kw<'if'> expr }
Generator { expr ~comp-or-mat GenFor ~gen-or-for (GenFor | GenFilter)* }

MatrixRow { (!mat expr)+ }

array {
  ( ComprehensionExpr { '[' Generator ']' }
  | MatrixExpr { '[' MatrixRow (_t MatrixRow)* _t? ']' }
  | VectorExpr { '[' sep<',', (!vec expr)> ']' }
  )
}

primary-expr {
  ( quotable
  | AdjointExpr { primary-expr !ctrans immediateQuote "'" }
  | CallExpr
  | ClosedMacrocallExpr
  | FieldExpr { primary-expr !dot immediateDot '.' (Identifier | string | QuoteExpr | ClosedMacrocallExpr) }
  | IndexExpr { primary-expr !call immediateBracket array }
  | ParametrizedExpr { primary-expr !call immediateBrace BraceExpr }
  | InterpExpr { '$' !quote (quotable | ClosedMacrocallExpr | Operator) }
  | QuoteExpr
  )
}

// FIXME: Use immediate*
QuoteExpr { ':' !quote (quotable | ClosedMacrocallExpr | Operator | SyntacticOperator) }

CallExpr {
  primary-expr !call immediateParen
  '('
  Arguments { sep<',', expr> }
  KeywordArguments { ';' sep<',', expr> }?
  ')'
}

ClosedMacrocallExpr {
  MacroIdentifier !call
  ( immediateBracket array
  | immediateBrace BraceExpr
  | immediateParen TupleExpr
  )
}


// OPERATIONS

operation {
  ( SplatExpr { expr !colon '...' }
  | ArrowFunctionExpr { (Identifier | TupleExpr) !afunc '->' !afunc (expr | Assignment) }
  | TernaryExpr { expr !ternary '?' !ternary expr !ternary ':' !ternary expr }
  | UnaryExpr {
      ( '::'
      | tilde-operator
      | type-operator
      | unary-operator
      | unary-plus-operator
      )
      !unary expr
    }
  | BinaryExpr {
      ( expr !where      kw<'where'> expr
      | expr !decl       '::' expr
      | expr !power      power-operator !power expr
      | expr !bitshift   bitshift-operator !bitshift expr
      | expr !rational   rational-operator !rational expr
      | expr !times      times-operator !times expr
      | expr !plus       (plus-operator | unary-plus-operator) !plus expr
      | expr !colon      (ellipsis-operator | ':') !colon expr
      | expr !pipe-right pipe-right-operator !pipe-right expr
      | expr !pipe-left  pipe-left-operator !pipe-left expr
      | expr !comparison (comparison-operator | type-operator | kw<'in'> | kw<'isa'>) !comparison expr
      | expr !lazy-and   lazy-and-operator expr
      | expr !lazy-or    lazy-or-operator expr
      | expr !arrow      arrow-operator !arrow expr
      | expr !pair       pair-operator !pair expr
      | expr !assignment (assignment-operator | tilde-operator) expr
      )
    }
  )
}

Operator {
  ( tilde-operator
  | type-operator
  | unary-operator
  | unary-plus-operator
  | power-operator
  | bitshift-operator
  | rational-operator
  | times-operator
  | plus-operator
  | ellipsis-operator
  | pipe-right-operator
  | pipe-left-operator
  | comparison-operator
  | arrow-operator
  | pair-operator
  )
}

// Operators that cannot be used as identifiers.
SyntacticOperator {
  ( '$'
  | '.'
  | '...'
  | lazy-and-operator
  | lazy-or-operator
  | '->'
  | '?'
  | eq-operator
  | assignment-operator
  )
}


// STRINGS

string {
  ( String1
  | String3
  | Command1
  | Command3
  | NsString1 { Identifier immediateDoubleQuote ns-str<'"', str1-content> }
  | NsString3 { Identifier immediateDoubleQuote ns-str<'"""', str3-content> }
  | NsCommand1 { Identifier immediateBackquote ns-str<'`', cmd1-content> }
  | NsCommand3 { Identifier immediateBackquote ns-str<'```', cmd3-content> }
  )
}

interp-expr { '(' expr ')' }

@skip {} {
  str<delim, content> { delim (content | EscapeSequence | Interpolation { '$' (Identifier | interp-expr) })* delim }
  ns-str<delim, content> { delim (content | '\\' | '$')* delim }

  String1 { str<'"', str1-content> }
  String3 { str<'"""', str3-content> }
  Command1 { str<'`', cmd1-content> }
  Command3 { str<'```', cmd3-content> }

  // Rules that should be tokens, but aren't...
  BlockComment { block-comment-start (block-comment-content | '#' | '=' | BlockComment)* '=#' }
  MacroIdentifier { '@' (Identifier | Operator | SyntacticOperator) }
}

// immediateIdentifier must be listed _before_ identifier.
// The order of external tokens matters!
@external tokens immediate from "./tokens.js" {
  immediateDot,
  // immediateColon,
  immediateBrace,
  immediateBracket,
  immediateParen,
  immediateBackquote,
  immediateDoubleQuote,
  immediateQuote,
  immediateIdentifier
}
@external tokens Identifier from "./tokens.js" { Identifier }
@external tokens terminator from "./tokens.js" { terminatorNewline }

_t { terminatorSemicolon | terminatorNewline }

@tokens {
  terminatorSemicolon { ';'+ }

  // Operators

  bdot<tokens> { '.'? tokens } // Broadcasting dot

  tilde-operator { bdot<'~'> } // unary / assignment
  type-operator { bdot<'<:' | '>:'> } // unary / comparison
  unary-operator { bdot<$[!¬√∛∜]> }
  unary-plus-operator { bdot<$[-+] | $[±∓]> }

  power-operator { bdot<'^' | $[↑↓⇵⟰⟱⤈⤉⤊⤋⤒⤓⥉⥌⥍⥏⥑⥔⥕⥘⥙⥜⥝⥠⥡⥣⥥⥮⥯￪￬]> }
  bitshift-operator { bdot<'<<' | '>>' | '>>>'> }
  rational-operator { bdot<'//'> }
  times-operator { bdot<$[*/%&\\] | $[⌿÷··⋅∘×∩∧⊗⊘⊙⊚⊛⊠⊡⊓∗∙∤⅋≀⊼⋄⋆⋇⋉⋊⋋⋌⋏⋒⟑⦸⦼⦾⦿⧶⧷⨇⨰⨱⨲⨳⨴⨵⨶⨷⨸⨻⨼⨽⩀⩃⩄⩋⩍⩎⩑⩓⩕⩘⩚⩜⩞⩟⩠⫛⊍▷⨝⟕⟖⟗⨟]> }
  plus-operator { bdot<'++' | '|' | $[−¦⊕⊖⊞⊟∪∨⊔∔∸≏⊎⊻⊽⋎⋓⟇⧺⧻⨈⨢⨣⨤⨥⨦⨧⨨⨩⨪⨫⨬⨭⨮⨹⨺⩁⩂⩅⩊⩌⩏⩐⩒⩔⩖⩗⩛⩝⩡⩢⩣]> }
  ellipsis-operator { '..' | bdot<$[…⁝⋮⋱⋰⋯]> }
  pipe-right-operator { bdot<'|>'> }
  pipe-left-operator { bdot<'<|'> }
  comparison-operator { bdot<'>=' | '<=' | '==' | '===' | '!=' | '!==' | $[><] | $[≥≤≡≠≢∈∉∋∌⊆⊈⊂⊄⊊∝∊∍∥∦∷∺∻∽∾≁≃≂≄≅≆≇≈≉≊≋≌≍≎≐≑≒≓≖≗≘≙≚≛≜≝≞≟≣≦≧≨≩≪≫≬≭≮≯≰≱≲≳≴≵≶≷≸≹≺≻≼≽≾≿⊀⊁⊃⊅⊇⊉⊋⊏⊐⊑⊒⊜⊩⊬⊮⊰⊱⊲⊳⊴⊵⊶⊷⋍⋐⋑⋕⋖⋗⋘⋙⋚⋛⋜⋝⋞⋟⋠⋡⋢⋣⋤⋥⋦⋧⋨⋩⋪⋫⋬⋭⋲⋳⋴⋵⋶⋷⋸⋹⋺⋻⋼⋽⋾⋿⟈⟉⟒⦷⧀⧁⧡⧣⧤⧥⩦⩧⩪⩫⩬⩭⩮⩯⩰⩱⩲⩳⩵⩶⩷⩸⩹⩺⩻⩼⩽⩾⩿⪀⪁⪂⪃⪄⪅⪆⪇⪈⪉⪊⪋⪌⪍⪎⪏⪐⪑⪒⪓⪔⪕⪖⪗⪘⪙⪚⪛⪜⪝⪞⪟⪠⪡⪢⪣⪤⪥⪦⪧⪨⪩⪪⪫⪬⪭⪮⪯⪰⪱⪲⪳⪴⪵⪶⪷⪸⪹⪺⪻⪼⪽⪾⪿⫀⫁⫂⫃⫄⫅⫆⫇⫈⫉⫊⫋⫌⫍⫎⫏⫐⫑⫒⫓⫔⫕⫖⫗⫘⫙⫷⫸⫹⫺⊢⊣⟂⫪⫫]> }
  lazy-and-operator { bdot<'&&'> }
  lazy-or-operator { bdot<'||'> }
  arrow-operator { bdot<'-->' | '<--' | '<-->' | $[←→↔↚↛↞↠↢↣↦↤↮⇎⇍⇏⇐⇒⇔⇴⇶⇷⇸⇹⇺⇻⇼⇽⇾⇿⟵⟶⟷⟹⟺⟻⟼⟽⟾⟿⤀⤁⤂⤃⤄⤅⤆⤇⤌⤍⤎⤏⤐⤑⤔⤕⤖⤗⤘⤝⤞⤟⤠⥄⥅⥆⥇⥈⥊⥋⥎⥐⥒⥓⥖⥗⥚⥛⥞⥟⥢⥤⥦⥧⥨⥩⥪⥫⥬⥭⥰⧴⬱⬰⬲⬳⬴⬵⬶⬷⬸⬹⬺⬻⬼⬽⬾⬿⭀⭁⭂⭃⥷⭄⥺⭇⭈⭉⭊⭋⭌￩￫⇜⇝↜↝↩↪↫↬↼↽⇀⇁⇄⇆⇇⇉⇋⇌⇚⇛⇠⇢↷↶↺↻]> }
  pair-operator { bdot<'=>'> }
  eq-operator { bdot<'='> }
  assignment-operator { ':=' | '$=' | bdot<$[≔⩴≕] | (bitshift-operator | '//' | $[-+*/\\^÷%|&⊻]) '='> }

  @precedence { assignment-operator, unary-plus-operator }


  // Numbers

  numeral<n> { n | (n (n | '_')* n) }
  dec { $[0-9] }
  hex { $[0-9A-Fa-f] }
  exp { $[Eef] $[+-]? dec+ }
  hex_exp { "p" $[+-]? dec+ }

  IntegerLiteral {
    numeral<dec>
    | '0b' numeral<$[01]>
    | '0o' numeral<$[0-7]>
    | '0x' numeral<hex>
  }

  FloatLiteral {
    numeral<dec> '.' numeral<dec>? exp?
    | '.' numeral<dec> exp?
    | '0x' numeral<hex> '.'? numeral<hex>? hex_exp
    | '0x.' numeral<hex> '.'? numeral<hex>? hex_exp
  }

  @precedence { '.', FloatLiteral, IntegerLiteral } // dot vs decimals, and floats vs integers


  // Characters & string content

  EscapeSequence {
    '\\'
    ( $[uU] hex hex hex hex
    | 'x' hex hex
    | $[0-7] $[0-7] $[0-7]
    | ![xuU]
    | '\\'
    )
  }

  CharLiteral { "'" (![\\'] | EscapeSequence) "'" }

  str1-content { !["$\\] }
  cmd1-content { ![`$\\] }
  str3-content { (str1-content | '"' (str1-content | '"' str1-content))+ }
  cmd3-content { (cmd1-content | '`' (cmd1-content | '`' cmd1-content))+ }


  // Comments & whitespace

  LineComment { "#" ![=\n]? ![\n]* }
  block-comment-content { ![#=] }
  block-comment-start { '#=' }
  _ws { @whitespace+ }

  @precedence { block-comment-start, LineComment }
}

# Modules

module A

baremodule B end

module C
end

end

==>
Program(
  ModuleDefinition(
    module,
    Identifier,
    ModuleDefinition(baremodule, Identifier, end),
    ModuleDefinition(module, Identifier, end),
    end
  )
)


# Abstract type definitions

abstract type T end
abstract type T <: S end
abstract type T{S} <: U end

==>
Program(
  AbstractDefinition(abstract, type, TypeHead(Identifier), end),
  AbstractDefinition(abstract, type, TypeHead(BinaryExpression(Identifier, Identifier)), end),
  AbstractDefinition(abstract, type, TypeHead(BinaryExpression(ParametrizedExpression(Identifier, BraceExpression(Identifier)), Identifier)), end),
)


# Primitive type definitions

primitive type T 8 end
primitive type T <: S 16 end
primitive type Ptr{T} 32 end

==>
Program(
  PrimitiveDefinition(primitive, type, TypeHead(Identifier), IntegerLiteral, end),
  PrimitiveDefinition(primitive, type, TypeHead(BinaryExpression(Identifier, Identifier)), IntegerLiteral, end),
  PrimitiveDefinition(primitive, type, TypeHead(ParametrizedExpression(Identifier, BraceExpression(Identifier))), IntegerLiteral, end),
)


# Struct definitions

struct Unit end

struct MyInt; field::Int end

==>
Program(
  StructDefinition(struct, TypeHead(Identifier), end),
  StructDefinition(struct, TypeHead(Identifier), BinaryExpression(Identifier, Identifier), end),
)


# Mutable struct definitions

mutable struct Bar
  baz
  qux::Float64
end

==>
Program(
  StructDefinition(
    mutable, struct,
    TypeHead(Identifier),
    Identifier,
    BinaryExpression(Identifier, Identifier),
    end
  ),
)


# Parametric struct definitions

struct Point{T}
  x::T
  y::T
end

==>
Program(
  StructDefinition(
    struct,
    TypeHead(ParametrizedExpression(Identifier, BraceExpression(Identifier))),
    BinaryExpression(Identifier, Identifier),
    BinaryExpression(Identifier, Identifier),
    end
  ),
)


# Parametric struct definitions with subtyping

struct Rational{T<:Integer} <: Real
  num::T
  den::T
end

==>
Program(
  StructDefinition(
    struct,
    TypeHead(
      BinaryExpression(
        ParametrizedExpression(Identifier, BraceExpression(BinaryExpression(Identifier, Identifier))),
        Identifier
      )
    ),
    BinaryExpression(Identifier, Identifier),
    BinaryExpression(Identifier, Identifier),
    end
  ),
)


# Parametric struct fields

mutable struct Foo <: Bar
  asd::Vector{Bar}
end

==>
Program(
  StructDefinition(
    mutable, struct,
    TypeHead(BinaryExpression(Identifier, Identifier)),
    BinaryExpression(Identifier, ParametrizedExpression(Identifier, BraceExpression(Identifier))),
    end
  ),
)


# Function definitions

function nop() end

function I(x) x end

function Base.rand(n::MyInt)
    return 4
end

function Γ(z)
    gamma(z)
end

==>
Program(
  FunctionDefinition(function, Signature(CallExpression(Identifier, Arguments)), end),
  FunctionDefinition(function, Signature(CallExpression(Identifier, Arguments(Identifier))), Identifier, end),
  FunctionDefinition(
    function,
    Signature(CallExpression(FieldExpression(Identifier, Identifier), Arguments(BinaryExpression(Identifier, Identifier)))),
    ReturnStatement(return, IntegerLiteral),
    end,
  ),
  FunctionDefinition(
    function,
    Signature(CallExpression(Identifier, Arguments(Identifier))),
    CallExpression(Identifier, Arguments(Identifier)),
    end,
  )
)

# Function definitions - Operators

function ⊕(x, y)
    x + y
end

===>
Program(
  FunctionDefinition(
    function,
    Signature(CallExpression(Operator, Arguments(Identifier, Identifier))),
    BinaryExpression(Identifier, Identifier),
    end,
  )
)


# Function definitions - Callable structs

function (foo::Foo)()
end

==>
Program(
  FunctionDefinition(
    function,
    Signature(CallExpression(ParenExpression(BinaryExpression(Identifier, Identifier)), Arguments)),
    end,
  )
)


# function definitions - Zero method definitions

function f end

==>
Program(
  FunctionDefinition(
    function,
    Signature(Identifier),
    end,
  )
)


# Function definitions - Anonymous functions

function fix2(f, x)
    return function(y,) # FIXME: Trailing comma
        f(x, y)
    end
end

==>
Program(
  FunctionDefinition(
    function,
    Signature(CallExpression(Identifier, Arguments(Identifier, Identifier))),
    ReturnStatement(
      return,
      FunctionDefinition(
        function,
        Signature(TupleExpression(Identifier)),
        LineComment,
        CallExpression(Identifier, Arguments(Identifier, Identifier)),
        end,
      )
    )
    end,
  )
)


# Functions with typed parameters # TODO
==>Program()

# Functions with optional and keyword parameters # TODO
==>Program()

# Functions definitions with type parameters # TODO
==>Program()


# Macro definitions

macro name(s::Symbol)
    String(s)
end

macro count(args...); length(args) end

==>
Program(
  MacroDefinition(
    macro,
    Signature(CallExpression(Identifier, Arguments(BinaryExpression(Identifier, Identifier)))),
    CallExpression(Identifier, Arguments(Identifier)),
    end
  ),
  MacroDefinition(
    macro,
    Signature(CallExpression(Identifier, Arguments(SplatExpression(Identifier)))),
    CallExpression(Identifier, Arguments(Identifier)),
    end
  ),
)

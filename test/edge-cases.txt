# Export statements - Macro identifier

export @macroname
export somename, @andamacroname, andsomethingelse

==>
SourceFile(
  ExportStatement(export, MacroIdentifier(MacroName)),
  ExportStatement(export, Identifier, MacroIdentifier(MacroName), Identifier),
)


# Import statements - import operators

import Module: ==, +

==>
SourceFile(
  ImportStatement(
    import,
    SelectedImport(Identifier, Operator, Operator)
  )
)


# Let statements - No let bindings

let
    code
end

==>
SourceFile(
  LetStatement(
    let,
    Identifier,
    end
  )
)


# Const statements - OpenTuple in assignment RHS

const x = a, b

==>
SourceFile(
  ConstStatement(
    const,
    AssignmentExpression(
      Identifier,
      BareTupleExpression(Identifier,Identifier)
    )
  )
)


# If statements - No terminator after condition

if true end
if true
end
if true x end
if true x else end
if true x else y end

==>
SourceFile(
  IfStatement(IfClause(if,BooleanLiteral()),end),
  IfStatement(IfClause(if,BooleanLiteral()),end),
  IfStatement(IfClause(if,BooleanLiteral()),Identifier,end),
  IfStatement(IfClause(if,BooleanLiteral()),Identifier,ElseClause(else),end),
  IfStatement(IfClause(if,BooleanLiteral()),Identifier,ElseClause(else,Identifier),end),
)


# While statements - Call as condition, no body

while call(); end

==>
SourceFile(
  WhileStatement(
    while,
    WhileBinding(CallExpression(Identifier,ArgumentList)),
    end
  )
)


# Function definitions - Keyword parameters

function a(;x,y) end
==>
SourceFile(FunctionDefinition(
  function,
  Definition(CallExpression(Identifier,ArgumentList(Parameters(Identifier,Identifier)))),
  end
))


# Function definitions - Anonymous function with keyword parameters

function (x; y) end
==>
SourceFile(FunctionDefinition(function,Definition(ArgumentList(Identifier,Parameters(Identifier))),end))


# Function definitions - Return type annotation

function f()::Int
end
==>
SourceFile(FunctionDefinition(
  function,
  Definition(
    TypedExpression(
      CallExpression(Identifier,ArgumentList),
      Type(Identifier),
    ),
  ),
  end
))


# Function definitions - return type annotation 2

function name()::T end
==>
SourceFile(
  FunctionDefinition(
    function,
    Definition(
      TypedExpression(
        CallExpression(
          Identifier,
          ArgumentList,
        ),
        Type(Identifier),
      ),
    )
    end
  )
)


# Function definitions - signature with `where` expression

function f()::T where T
end
==>
SourceFile(
  FunctionDefinition(
    function,
    Definition(
      TypedExpression(
        CallExpression(Identifier, ArgumentList),
        Type(Identifier),
      )
    ),
    where,
    TypeParameters(Identifier),
    end
  )
)

# Function definitions - Anonymous function, no parameters

function() end
function()
end

==>
SourceFile(
  FunctionDefinition(function,Definition(ArgumentList),end),
  FunctionDefinition(function,Definition(ArgumentList),end),
)


# Function definitions - zero method definitions

function name end

==>
SourceFile(
  FunctionDefinition(function,Definition(Identifier),end)
)


# Function definitions - Implicit typed parameter (unary `::`)

function name(arg::A, ::B)
  ok
end

==>
SourceFile(
  FunctionDefinition(
    function,
    Definition(
      CallExpression(
        Identifier,
        ArgumentList(
          TypedExpression(Identifier,Type(Identifier)),
          LonelyType(Type(Identifier))
        ),
      ),
    ),
    Identifier,
    end
  )
)


# Function definitions - FieldExpression as type of parameter

function name(param::Type.Some) end

==>

SourceFile(
  FunctionDefinition(
    function,
    Definition(
      CallExpression(
        Identifier,
        ArgumentList(TypedExpression(Identifier,Type(FieldExpression(Identifier,FieldName)))),
      )
    ),
    end
  )
)


# Macro definitions - FieldExpression as macro name

macro Base.union() end

==>
SourceFile(
  MacroDefinition(
    macro,
    Definition(FieldExpression(Identifier,FieldName)),
    ArgumentList,
    end
  )
)


# Abstract type definitions - Type parameters

abstract type name{a} end
abstract type name{a,b} end
abstract type name{a,} end
abstract type name{a,b,} end
abstract type name{a<:b} end
abstract type name{a<:b,} end
abstract type name{a, a<:b} end
abstract type name{a, a<:b,} end

==>
SourceFile(
  AbstractDefinition(abstract,type,Definition(ParameterizedIdentifier(Identifier,TypeArgumentList(Identifier))),end),
  AbstractDefinition(abstract,type,Definition(ParameterizedIdentifier(Identifier,TypeArgumentList(Identifier,Identifier))),end),
  AbstractDefinition(abstract,type,Definition(ParameterizedIdentifier(Identifier,TypeArgumentList(Identifier))),end),
  AbstractDefinition(abstract,type,Definition(ParameterizedIdentifier(Identifier,TypeArgumentList(Identifier,Identifier))),end),
  AbstractDefinition(abstract,type,Definition(ParameterizedIdentifier(Identifier,TypeArgumentList(SubtypedExpression(Identifier,Identifier)))),end),
  AbstractDefinition(abstract,type,Definition(ParameterizedIdentifier(Identifier,TypeArgumentList(SubtypedExpression(Identifier,Identifier)))),end),
  AbstractDefinition(abstract,type,Definition(ParameterizedIdentifier(Identifier,TypeArgumentList(Identifier,SubtypedExpression(Identifier,Identifier)))),end),
  AbstractDefinition(abstract,type,Definition(ParameterizedIdentifier(Identifier,TypeArgumentList(Identifier,SubtypedExpression(Identifier,Identifier)))),end)
)


# String literals - Escaped backslash

"\\" # i am a comment "
==>
SourceFile(String, Comment)


# NsStringLiteral - no interpolation

md"$(x)"
==>
SourceFile(PrefixedString(Prefix(Identifier),String))


# Named tuples - leading semicolon `;`
(;x,y)
==>
SourceFile(TupleExpression(Parameters(Identifier,Identifier)))


# Generator expressions - generators as function argument
sum(x for x in g)
==>
SourceFile(
  CallExpression(
    Identifier,
    ArgumentList(
      ListCompherension(Identifier,ForClause(for,ForBinding(Identifier,AssignOperator(in),Identifier))),
    ),
  ),
)


# Generator expressions - generators with multiple bindings as function argument
sum(x for x in g, y in z)
sum(c for c in d, e = 5)
==>
SourceFile(
  CallExpression(
    Identifier,
    ArgumentList(
      ListCompherension(
        Identifier,
        ForClause(
          for,
          ForBinding(Identifier,AssignOperator(in),Identifier),
          ForBinding(Identifier,AssignOperator(in),Identifier),
        ),
      ),
    ),
  ),
  CallExpression(
    Identifier,
    ArgumentList(
      ListCompherension(
        Identifier,
        ForClause(
          for,
          ForBinding(Identifier,AssignOperator(in),Identifier),
          ForBinding(Identifier,AssignOperator("="),Number),
        ),
      ),
    ),
  ),
)


# Adjoint expressions

A'B:C'D

==>

SourceFile(BinaryExpression(
  CoefficientExpression(
    TransposeExpression(Identifier),
    Coefficient(Identifier),
  ),
  CoefficientExpression(
    TransposeExpression(Identifier),
    Coefficient(Identifier),
  ),
))

# Adjoint expressions - 2
a'
==>
SourceFile(TransposeExpression(Identifier))

# Adjoint expressions - 3
Bread' * Meat * Bread
==>
SourceFile(BinaryExpression(BinaryExpression(TransposeExpression(Identifier),Identifier),Identifier))


# Field expressions - NsStringLiteral RHS

module.macro"aaa"
==>
SourceFile()


# Field expressions - Keywords as field name

object.if
==>
SourceFile(FieldExpression(Identifier,FieldName))


# Index expressions - typed comprehensions

arr[x for x in xs]

==>
SourceFile(
  SubscriptExpression(
    Identifier,
    ListCompherension(
      Identifier,
      ForClause(for,ForBinding(Identifier,AssignOperator(in),Identifier))
    ),
  ),
)


# Symbols - quoted keywords

:if
==>
SourceFile(Symbol(SymbolName))


# Interpolation expressions - interpolation in hcat

:([x $y])
==>
SourceFile(
  QuoteExpression(ParenthesizedExpression(
    MatrixExpression(MatrixRow(
      Identifier,
      InterpolationExpression(Identifier),
    )),
  )),
)


# Type parametrized expression

Type{<:Hi, ::Wow}
==>
SourceFile(ParameterizedIdentifier(Identifier,TypeArgumentList(LonelyType("<:",Type(Identifier)),LonelyType("::",Type(Identifier)))))


# Function calls - Broadcast call
zip.(xs)
==>
SourceFile(CallExpression(Identifier,BroadcastDot,ArgumentList(Identifier)))


# Function calls - keyword arguments
a(;x,y)
==>
SourceFile(CallExpression(Identifier,ArgumentList(Parameters(Identifier,Identifier))))


# Function calls - Broadcast-dot-operator-call
.!(true, true, false)
==>
SourceFile(CallExpression(Operator,ArgumentList(BooleanLiteral,BooleanLiteral,BooleanLiteral)))

# Function calls - Broadcast-dot-operator
.!isnan.([1,2,3])
==>
SourceFile(UnaryExpression(Operator,CallExpression(Identifier,BroadcastDot,ArgumentList(ArrayExpression(Number,Number,Number)))))


# Do blocks - no parameters
f() do; end
==>
SourceFile(CallExpression(Identifier,ArgumentList,DoClause(do,end)))


# Do blocks - one parameter
f() do x x end
==>
SourceFile(CallExpression(Identifier,ArgumentList,DoClause(do,DoClauseArguments(Identifier),Identifier,end)))


# Do blocks - typed parameter
f() do x::Int; end
==>
SourceFile(CallExpression(Identifier,ArgumentList,DoClause(do,DoClauseArguments(TypedExpression(Identifier,"::",Type(Identifier))),end)))


# Macro call expressions - do block
@test() do x, y

end
==>
SourceFile(MacroExpression(MacroIdentifier(MacroName),ArgumentList,DoClause(do,DoClauseArguments(Identifier,Identifier),end)))


# Macro call expressions - Qualified name with @ at the beginning
@Test.test 1 == 1
==>
SourceFile(
  MacroExpression(
    MacroFieldExpression(MacroIdentifier(MacroName),MacroFieldName),
    MacroArgumentList(BinaryExpression(Number,Number))
  )
)


# Macro call expressions - brace arguments
@NamedTuple{a::Float64, b::String}
==>
SourceFile(MacroExpression(
  MacroIdentifier(MacroName),
  TypeArgumentList(
    TypedExpression(Identifier,"::",Type(Identifier)),
    TypedExpression(Identifier,"::",Type(Identifier)),
  )
))


# Macro call expressions - nested assignments arguments
@macro x = x = x
==>
SourceFile(MacroExpression(MacroIdentifier(MacroName),MacroArgumentList(AssignmentExpression(Identifier,AssignmentExpression(Identifier,Identifier)))))


# Macro call expressions - OpenTuple arguments
@macro x, y, z x, y, z
==>
SourceFile(MacroExpression(
  MacroIdentifier(MacroName),
  MacroArgumentList(
    BareTupleExpression(Identifier,Identifier,Identifier),
    BareTupleExpression(Identifier,Identifier,Identifier),
  )
))


# Macro call expressions - arguments spanning multiple lines

@name a +
  2

==>
SourceFile(
  MacroExpression(
    MacroIdentifier(MacroName),
    MacroArgumentList(BinaryExpression(Identifier,Number))
  )
)


# Macro call expressions - blocks as arguments

@name a begin
  b
end

==>
SourceFile(
  MacroExpression(
    MacroIdentifier(MacroName),
    MacroArgumentList(Identifier,CompoundExpression(begin,Identifier,end))
  )
)


# Macro call expressions - Qualified macro name (FieldExpression)

Base.@name

==>
SourceFile(
  MacroExpression(
    MacroFieldExpression(Identifier,MacroIdentifier(MacroName))
  )
)


# Macro calls - Assignments as arguments

@eval a = 2

==>
SourceFile(
  MacroExpression(
    MacroIdentifier(MacroName),
    MacroArgumentList(AssignmentExpression(Identifier,Number))
  )
)


# Assignments - short function definitions

name(a, b) = a + b

==>
SourceFile(
  FunctionAssignmentExpression(
    CallExpression(Identifier, ArgumentList(Identifier,Identifier)),
    BinaryExpression(Identifier,Identifier)
  )
)


# Assignments - short function definitions - where expression

name(a::T) where {T} = a

==>
SourceFile(
  FunctionAssignmentExpression(
    CallExpression(Identifier, ArgumentList(TypedExpression(Identifier,Type(Identifier)))),
    where,TypeArgumentList(Identifier),
    Identifier
  )
)


# Arrow function expressions - Ternary expression in RHS
y -> y ? x : 10
==>
SourceFile(FunctionExpression(Identifier,TernaryExpression(Identifier,Identifier,Number)))


# Arrow function expressions - Arrow function as argument
foreach(c -> c.queued, cells)
==>
SourceFile(CallExpression(
  Identifier,
  ArgumentList(
    FunctionExpression(Identifier,FieldExpression(Identifier,FieldName)),
    Identifier,
  ),
))


# Arrow function expressions - assignment in RHS
foreach(c -> c.queued = true)
==>
SourceFile(CallExpression(Identifier,ArgumentList(FunctionExpression(Identifier,AssignmentExpression(FieldExpression(Identifier,FieldName),BooleanLiteral)))))


# Arrow function expressions - Arrow function as argument and assignment in RHS
foreach(c -> c.queued = true, cells)
==>
SourceFile(CallExpression(
  Identifier,
  ArgumentList(
    FunctionExpression(
      Identifier,
      AssignmentExpression(FieldExpression(Identifier,FieldName),BooleanLiteral)
    ),
    Identifier,
  )
))


# Juxtaposition expressions - Number LHS with with tuple RHS
1(x, y)
==>
SourceFile(CoefficientExpression(Number,Coefficient(TupleExpression(Identifier,Identifier))))


# Juxtaposition expressions - FieldExpression RHS
10x.a
==>
SourceFile(CoefficientExpression(Number,Coefficient(FieldExpression(Identifier,FieldName))))

# Juxtaposition expressions - function as RHS
2xxx()
==>
SourceFile(
  CoefficientExpression(
    Number,
    Coefficient(
      CallExpression(Identifier,ArgumentList),
    ),
  ),
)


# Operators as identifiers - More operators as standalone
(!)
@>:
==>
SourceFile(
    ParenthesizedExpression(Operator),
    MacroExpression(MacroIdentifier(MacroName(Operator)),MacroArgumentList(Operator))
)


# Operators as identifiers - BROKEN: Just operators hanging out
!
.!
.<:
.>:
==>
SourceFile(Operator,Operator,Operator,Operator)

# Bitwise operator - Huh? Bitwise operators weren't in here?
1 | x
==>
SourceFile(BinaryExpression(Number,Identifier))

# Arrow operators - I mean com'on this is easy operator stuff
a .=> x
a .<| b
a |> b .<| c
==>
SourceFile(
  BinaryExpression(Identifier,Identifier),
  BinaryExpression(Identifier,"pipe<",Identifier),
  BinaryExpression(BinaryExpression(Identifier,"pipe>",Identifier),"pipe<",Identifier)
)

# Bitshift operators - BinaryExpression_bitshift_ok

a >> 2
b << 2
c >>> 3

==>
SourceFile(
  BinaryExpression(Identifier,Number),
  BinaryExpression(Identifier,Number),
  BinaryExpression(Identifier,Number)
)


# Binary expressions - operands spanning multiple lines

1 +
2

==>
SourceFile(BinaryExpression(Number,Number))


# Range binary expressions

a:b

==>
SourceFile(BinaryExpression(Identifier,Identifier))


# IDK

begin
	function under_root(x)
		ret = 2exp(+x+2) + 1
	end
end

==>
SourceFile(
  CompoundExpression(
    begin,
    FunctionDefinition(
      function,
      Definition(CallExpression(
        Identifier,
        ArgumentList(Identifier),
      )),
      AssignmentExpression(
        Identifier,
        BinaryExpression(
          CoefficientExpression(
            Number,
            Coefficient(
              CallExpression(
                Identifier,
                ArgumentList(BinaryExpression(UnaryExpression(Operator, Identifier),Number)),
              ),
            ),
          ),
          Number,
        ),
      ),
      end
    ),
    end,
  )
)


# IDK - Why though (Not sure why this was fixed but it was...????)
function pumas_be(
    data::AbstractDataFrame;
	  method::B = :AUC,
    logtransformed::B = a,
    period::Union{a} = a,
    reference::Union{a} = a,
    reml::B = a,
)
    a
end
==>
SourceFile(FunctionDefinition(function,Definition(CallExpression(Identifier,ArgumentList(
  TypedExpression(Identifier,"::",Type(Identifier)),
  Parameters(
    AssignmentExpression(TypedExpression(Identifier,"::",Type(Identifier)),Symbol(SymbolName)),
    AssignmentExpression(TypedExpression(Identifier,"::",Type(Identifier)),Identifier),
    AssignmentExpression(TypedExpression(Identifier,"::",Type(ParameterizedIdentifier(Identifier,TypeArgumentList(Identifier)))),Identifier),
    AssignmentExpression(TypedExpression(Identifier,"::",Type(ParameterizedIdentifier(Identifier,TypeArgumentList(Identifier)))),Identifier),
    AssignmentExpression(TypedExpression(Identifier,"::",Type(Identifier)),Identifier))
))),Identifier,end))

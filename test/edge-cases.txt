# Adjoint expressions

A'B:C'D

==>

SourceFile(BinaryExpression(
  CoefficientExpression(
    TransposeExpression(Identifier),
    Coefficient(Identifier),
  ),
  CoefficientExpression(
    TransposeExpression(Identifier),
    Coefficient(Identifier),
  ),
))

# Adjoint expressions - 2
a'
==>
SourceFile(TransposeExpression(Identifier))

# Adjoint expressions - 3
Bread' * Meat * Bread
==>
SourceFile(BinaryExpression(BinaryExpression(TransposeExpression(Identifier),Identifier),Identifier))


# Field expressions - NsStringLiteral RHS

module.macro"aaa"
==>
SourceFile()


# Field expressions - Keywords as field name

object.if
==>
SourceFile(FieldExpression(Identifier,FieldName))


# Index expressions - typed comprehensions

arr[x for x in xs]

==>
SourceFile(
  SubscriptExpression(
    Identifier,
    ListCompherension(
      Identifier,
      ForClause(for,ForBinding(Identifier,AssignOperator(in),Identifier))
    ),
  ),
)


# Symbols - quoted keywords

:if
==>
SourceFile(Symbol(SymbolName))


# Interpolation expressions - interpolation in hcat

:([x $y])
==>
SourceFile(
  QuoteExpression(ParenthesizedExpression(
    MatrixExpression(MatrixRow(
      Identifier,
      InterpolationExpression(Identifier),
    )),
  )),
)


# Type parametrized expression

Type{<:Hi, ::Wow}
==>
SourceFile(ParameterizedIdentifier(Identifier,TypeArgumentList(LonelyType("<:",Type(Identifier)),LonelyType("::",Type(Identifier)))))


# Function calls - Broadcast call
zip.(xs)
==>
SourceFile(CallExpression(Identifier,BroadcastDot,ArgumentList(Identifier)))


# Function calls - keyword arguments
a(;x,y)
==>
SourceFile(CallExpression(Identifier,ArgumentList(Parameters(Identifier,Identifier))))


# Function calls - Broadcast-dot-operator-call
.!(true, true, false)
==>
SourceFile(CallExpression(Operator,ArgumentList(BooleanLiteral,BooleanLiteral,BooleanLiteral)))

# Function calls - Broadcast-dot-operator
.!isnan.([1,2,3])
==>
SourceFile(UnaryExpression(Operator,CallExpression(Identifier,BroadcastDot,ArgumentList(ArrayExpression(Number,Number,Number)))))


# Do blocks - no parameters
f() do; end
==>
SourceFile(CallExpression(Identifier,ArgumentList,DoClause(do,end)))


# Do blocks - one parameter
f() do x x end
==>
SourceFile(CallExpression(Identifier,ArgumentList,DoClause(do,DoClauseArguments(Identifier),Identifier,end)))


# Do blocks - typed parameter
f() do x::Int; end
==>
SourceFile(CallExpression(Identifier,ArgumentList,DoClause(do,DoClauseArguments(TypedExpression(Identifier,"::",Type(Identifier))),end)))


# Macro call expressions - do block
@test() do x, y

end
==>
SourceFile(MacroExpression(MacroIdentifier(MacroName),ArgumentList,DoClause(do,DoClauseArguments(Identifier,Identifier),end)))


# Macro call expressions - Qualified name with @ at the beginning
@Test.test 1 == 1
==>
SourceFile(
  MacroExpression(
    MacroFieldExpression(MacroIdentifier(MacroName),MacroFieldName),
    MacroArgumentList(BinaryExpression(Number,Number))
  )
)


# Macro call expressions - brace arguments
@NamedTuple{a::Float64, b::String}
==>
SourceFile(MacroExpression(
  MacroIdentifier(MacroName),
  TypeArgumentList(
    TypedExpression(Identifier,"::",Type(Identifier)),
    TypedExpression(Identifier,"::",Type(Identifier)),
  )
))


# Macro call expressions - nested assignments arguments
@macro x = x = x
==>
SourceFile(MacroExpression(MacroIdentifier(MacroName),MacroArgumentList(AssignmentExpression(Identifier,AssignmentExpression(Identifier,Identifier)))))


# Macro call expressions - OpenTuple arguments
@macro x, y, z x, y, z
==>
SourceFile(MacroExpression(
  MacroIdentifier(MacroName),
  MacroArgumentList(
    BareTupleExpression(Identifier,Identifier,Identifier),
    BareTupleExpression(Identifier,Identifier,Identifier),
  )
))


# Macro call expressions - arguments spanning multiple lines

@name a +
  2

==>
SourceFile(
  MacroExpression(
    MacroIdentifier(MacroName),
    MacroArgumentList(BinaryExpression(Identifier,Number))
  )
)


# Macro call expressions - blocks as arguments

@name a begin
  b
end

==>
SourceFile(
  MacroExpression(
    MacroIdentifier(MacroName),
    MacroArgumentList(Identifier,CompoundExpression(begin,Identifier,end))
  )
)


# Macro call expressions - Qualified macro name (FieldExpression)

Base.@name

==>
SourceFile(
  MacroExpression(
    MacroFieldExpression(Identifier,MacroIdentifier(MacroName))
  )
)


# Macro calls - Assignments as arguments

@eval a = 2

==>
SourceFile(
  MacroExpression(
    MacroIdentifier(MacroName),
    MacroArgumentList(AssignmentExpression(Identifier,Number))
  )
)


# Assignments - short function definitions

name(a, b) = a + b

==>
SourceFile(
  FunctionAssignmentExpression(
    CallExpression(Identifier, ArgumentList(Identifier,Identifier)),
    BinaryExpression(Identifier,Identifier)
  )
)


# Assignments - short function definitions - where expression

name(a::T) where {T} = a

==>
SourceFile(
  FunctionAssignmentExpression(
    CallExpression(Identifier, ArgumentList(TypedExpression(Identifier,Type(Identifier)))),
    where,TypeArgumentList(Identifier),
    Identifier
  )
)


# Arrow function expressions - Ternary expression in RHS
y -> y ? x : 10
==>
SourceFile(FunctionExpression(Identifier,TernaryExpression(Identifier,Identifier,Number)))


# Arrow function expressions - Arrow function as argument
foreach(c -> c.queued, cells)
==>
SourceFile(CallExpression(
  Identifier,
  ArgumentList(
    FunctionExpression(Identifier,FieldExpression(Identifier,FieldName)),
    Identifier,
  ),
))


# Arrow function expressions - assignment in RHS
foreach(c -> c.queued = true)
==>
SourceFile(CallExpression(Identifier,ArgumentList(FunctionExpression(Identifier,AssignmentExpression(FieldExpression(Identifier,FieldName),BooleanLiteral)))))


# Arrow function expressions - Arrow function as argument and assignment in RHS
foreach(c -> c.queued = true, cells)
==>
SourceFile(CallExpression(
  Identifier,
  ArgumentList(
    FunctionExpression(
      Identifier,
      AssignmentExpression(FieldExpression(Identifier,FieldName),BooleanLiteral)
    ),
    Identifier,
  )
))


# Juxtaposition expressions - Number LHS with with tuple RHS
1(x, y)
==>
SourceFile(CoefficientExpression(Number,Coefficient(TupleExpression(Identifier,Identifier))))


# Juxtaposition expressions - FieldExpression RHS
10x.a
==>
SourceFile(CoefficientExpression(Number,Coefficient(FieldExpression(Identifier,FieldName))))

# Juxtaposition expressions - function as RHS
2xxx()
==>
SourceFile(
  CoefficientExpression(
    Number,
    Coefficient(
      CallExpression(Identifier,ArgumentList),
    ),
  ),
)


# Operators as identifiers - More operators as standalone
(!)
@>:
==>
SourceFile(
    ParenthesizedExpression(Operator),
    MacroExpression(MacroIdentifier(MacroName(Operator)),MacroArgumentList(Operator))
)


# Operators as identifiers - BROKEN: Just operators hanging out
!
.!
.<:
.>:
==>
SourceFile(Operator,Operator,Operator,Operator)

# Bitwise operator - Huh? Bitwise operators weren't in here?
1 | x
==>
SourceFile(BinaryExpression(Number,Identifier))

# Arrow operators - I mean com'on this is easy operator stuff
a .=> x
a .<| b
a |> b .<| c
==>
SourceFile(
  BinaryExpression(Identifier,Identifier),
  BinaryExpression(Identifier,"pipe<",Identifier),
  BinaryExpression(BinaryExpression(Identifier,"pipe>",Identifier),"pipe<",Identifier)
)

# Bitshift operators - BinaryExpression_bitshift_ok

a >> 2
b << 2
c >>> 3

==>
SourceFile(
  BinaryExpression(Identifier,Number),
  BinaryExpression(Identifier,Number),
  BinaryExpression(Identifier,Number)
)


# Binary expressions - operands spanning multiple lines

1 +
2

==>
SourceFile(BinaryExpression(Number,Number))


# Range binary expressions

a:b

==>
SourceFile(BinaryExpression(Identifier,Identifier))


# IDK

begin
	function under_root(x)
		ret = 2exp(+x+2) + 1
	end
end

==>
SourceFile(
  CompoundExpression(
    begin,
    FunctionDefinition(
      function,
      Definition(CallExpression(
        Identifier,
        ArgumentList(Identifier),
      )),
      AssignmentExpression(
        Identifier,
        BinaryExpression(
          CoefficientExpression(
            Number,
            Coefficient(
              CallExpression(
                Identifier,
                ArgumentList(BinaryExpression(UnaryExpression(Operator, Identifier),Number)),
              ),
            ),
          ),
          Number,
        ),
      ),
      end
    ),
    end,
  )
)


# IDK - Why though (Not sure why this was fixed but it was...????)
function pumas_be(
    data::AbstractDataFrame;
	  method::B = :AUC,
    logtransformed::B = a,
    period::Union{a} = a,
    reference::Union{a} = a,
    reml::B = a,
)
    a
end
==>
SourceFile(FunctionDefinition(function,Definition(CallExpression(Identifier,ArgumentList(
  TypedExpression(Identifier,"::",Type(Identifier)),
  Parameters(
    AssignmentExpression(TypedExpression(Identifier,"::",Type(Identifier)),Symbol(SymbolName)),
    AssignmentExpression(TypedExpression(Identifier,"::",Type(Identifier)),Identifier),
    AssignmentExpression(TypedExpression(Identifier,"::",Type(ParameterizedIdentifier(Identifier,TypeArgumentList(Identifier)))),Identifier),
    AssignmentExpression(TypedExpression(Identifier,"::",Type(ParameterizedIdentifier(Identifier,TypeArgumentList(Identifier)))),Identifier),
    AssignmentExpression(TypedExpression(Identifier,"::",Type(Identifier)),Identifier))
))),Identifier,end))
